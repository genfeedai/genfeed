# Session: 2026-01-18

## Session 1: Gallery Page Implementation

### Summary
Implemented a complete `/gallery` page feature for displaying generated assets (images, videos, audio) from local output folders.

### Tasks Completed

1. **Gallery Page Core Implementation**
   - Created `/gallery` route with responsive grid layout
   - Added lightbox modal for full-size previews
   - Supports images, videos, and audio files

2. **API Routes**
   - `GET /api/gallery` - Lists all files from output directories
   - `GET /api/gallery/[...path]` - Serves individual files with proper MIME types
   - `DELETE /api/gallery/[...path]` - Deletes files from output folders

3. **Enhancements**
   - Navigation link added to dashboard header
   - Keyboard navigation (←/→ arrows, Escape to close)
   - Delete functionality with confirmation
   - Refresh button to reload gallery

### Files Created

```
apps/web/src/lib/gallery/types.ts          # GalleryItem interface, extensions, MIME types
apps/web/src/app/api/gallery/route.ts      # List API endpoint
apps/web/src/app/api/gallery/[...path]/route.ts  # Serve/Delete API endpoint
apps/web/src/components/gallery/LightboxModal.tsx  # Fullscreen preview modal
apps/web/src/components/gallery/GalleryItem.tsx    # Individual item card
apps/web/src/components/gallery/GalleryGrid.tsx    # Responsive grid wrapper
apps/web/src/app/gallery/page.tsx          # Gallery page component
output/images/.gitkeep                      # Output directory placeholder
output/videos/.gitkeep                      # Output directory placeholder
output/audio/.gitkeep                       # Output directory placeholder
```

### Files Modified

```
apps/web/src/app/page.tsx                  # Added Gallery link to header
.gitignore                                  # Added output/* exclusions
```

### Technical Decisions

1. **Output folder location**: `core/output/` at monorepo root (not in public/)
   - Requires API routes to serve files
   - Allows dynamic file management (delete)

2. **State management**: Local component state (no Zustand store)
   - Gallery data is page-specific, not shared
   - Simpler implementation

3. **File serving**: API route with path validation
   - Prevents directory traversal attacks
   - Sets proper Content-Type and caching headers

4. **Audio support**: Added alongside images/videos
   - Extensions: .mp3, .wav, .ogg, .m4a, .aac
   - Custom UI with Music icon for thumbnails and lightbox

### Patterns Established

- Gallery items use base64url-encoded path as unique ID
- Files sorted by modification date (newest first)
- Lightbox supports prev/next navigation with keyboard
- Delete auto-advances to next item

### How to Test

1. Add test files to `output/images/`, `output/videos/`, or `output/audio/`
2. Start dev server: `bun run dev` (from web app)
3. Visit `http://localhost:3000/gallery`
4. Test: grid display, lightbox, navigation, delete, refresh

---

## Session 2: Ngrok Tunnel Integration for Replicate Webhooks

### Summary
Implemented an automated ngrok tunnel script that starts a tunnel, updates `.env` files with the public webhook URL, and launches the dev server - all in one command.

### System Flow

```
┌─────────────────────────────────────────────────────────────┐
│  bun run dev:tunnel                                         │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
                 ┌────────────────────────┐
                 │  Start ngrok tunnel    │
                 │  (port 3001)           │
                 └────────────────────────┘
                              │
                              ▼
                 ┌────────────────────────┐
                 │  Get public URL        │
                 │  https://xxx.ngrok.io  │
                 └────────────────────────┘
                              │
                              ▼
                 ┌────────────────────────┐
                 │  Update .env files     │
                 │  WEBHOOK_BASE_URL=url  │
                 └────────────────────────┘
                              │
                              ▼
                 ┌────────────────────────┐
                 │  Start dev server      │
                 │  (bun run dev)         │
                 └────────────────────────┘
                              │
                              ▼
        ┌─────────────────────┴─────────────────────┐
        │                                           │
        ▼                                           ▼
┌───────────────┐                         ┌─────────────────┐
│  API (3001)   │ ◄─── ngrok tunnel ◄───  │  Replicate      │
│  /api/replicate/webhook                 │  webhooks       │
└───────────────┘                         └─────────────────┘
```

### Tasks Completed

1. **Research** - Explored codebase to understand current webhook setup (no existing tunnel solution)
2. **Install dependency** - Added `@ngrok/ngrok@1.7.0` as dev dependency
3. **Create tunnel script** - `scripts/dev-tunnel.ts` with all-in-one functionality
4. **Add npm script** - `bun run dev:tunnel` in package.json

### Files Created

```
scripts/dev-tunnel.ts    # Ngrok tunnel + env update + dev server launcher
```

### Files Modified

```
package.json             # Added @ngrok/ngrok dependency, dev:tunnel script
```

### Technical Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Ngrok package | `@ngrok/ngrok` (official SDK) | Modern API, TypeScript support, actively maintained |
| Workflow | All-in-one command | User requested single command for tunnel + dev |
| Env files | Update `.env` and `apps/api/.env` | Both locations used by different parts of codebase |
| Cleanup | SIGINT handler | Graceful shutdown of tunnel and dev server on Ctrl+C |

### Usage

```bash
# Set ngrok auth token (one time)
export NGROK_AUTHTOKEN=your_token

# Start everything
bun run dev:tunnel
```

### Patterns Established

- Dev tooling scripts go in `scripts/` directory
- Use Bun shebang: `#!/usr/bin/env bun`
- Tunnel scripts update both root and app-specific .env files

---

## Session 3: Video Frame Extract Node (FFmpeg-based)

### Summary
Implemented a VideoFrameExtract node that extracts frames from videos using FFmpeg, enabling users to chain video generations for longer content. The workflow pattern: `VideoGen → FrameExtract → LLM (continuation) → VideoGen → VideoStitch`.

### Tasks Completed

1. **Type Definitions** - Added `FrameSelectionMode`, `VideoFrameExtractNodeData`, NODE_DEFINITIONS entry
2. **Frontend Component** - Created `VideoFrameExtractNode.tsx` with selection mode UI
3. **FFmpeg Service** - Built local frame extraction using native FFmpeg commands
4. **Queue Integration** - Added processor case, queue mapping, job data interface
5. **Template** - Created "Extended Video Pipeline" example workflow
6. **Documentation** - Replaced default NestJS README with project-specific docs

### Files Created

```
apps/web/src/components/nodes/processing/VideoFrameExtractNode.tsx  # Frontend node component
apps/api/src/ffmpeg/ffmpeg.service.ts    # FFmpeg frame extraction service
apps/api/src/ffmpeg/ffmpeg.module.ts     # NestJS module
apps/api/src/ffmpeg/index.ts             # Barrel export
apps/web/src/templates/generated/extended-video.ts  # Example workflow template
```

### Files Modified

```
packages/types/src/nodes.ts              # FrameSelectionMode, VideoFrameExtractNodeData, NODE_DEFINITIONS
apps/web/src/components/nodes/processing/index.ts  # Export VideoFrameExtractNode
apps/web/src/components/nodes/index.ts   # Register in nodeTypes
apps/web/src/components/nodes/BaseNode.tsx  # Added Film icon
apps/api/src/queue/interfaces/job-data.interface.ts  # VideoFrameExtractJobData
apps/api/src/queue/processors/processing.processor.ts  # Added videoFrameExtract case
apps/api/src/queue/queue.constants.ts    # Queue mapping
apps/api/src/queue/queue.module.ts       # Import FFmpegModule
apps/web/src/templates/index.ts          # Register template
apps/api/README.md                       # Complete rewrite with project docs
```

### Technical Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Frame extraction | FFmpeg (not Replicate AI) | User requested: "can't we do it with ffmpeg? do we really need ai to extract a frame?" |
| Selection modes | first/last/timestamp/percentage | Flexible frame selection for different use cases |
| Output format | Base64 data URL | Consistent with existing image handling in the system |
| Workflow type | Manual chaining | User connects FrameExtract → VideoGen nodes manually |
| Prompt strategy | LLM continuation | LLM generates evolving prompts for scene continuity |

### Selection Modes

- `first` - Extract first frame: `ffmpeg -y -i video -vframes 1 output.jpg`
- `last` - Extract last frame: `ffmpeg -y -sseof -1 -i video -vframes 1 output.jpg`
- `timestamp` - Extract at seconds: `ffmpeg -y -ss {seconds} -i video -vframes 1 output.jpg`
- `percentage` - Extract at position: Calculate seek time from duration

### Workflow Pattern

```
Prompt Input
     │
     ▼
VideoGen (first segment)
     │
     ▼
FrameExtract (last frame)
     │
     ▼
LLM (continuation prompt)
     │
     ▼
VideoGen (second segment)
     │
     ▼
VideoStitch (combine)
     │
     ▼
Output
```

### Requirements

- FFmpeg must be installed on the server
- Videos processed locally (no external API calls)
- Node appears in Studio under "Processing" category

---

## Session 4: Avatar Workflow - Talking Head Video Generation

### Summary
Implemented a complete avatar workflow for generating talking head videos from a static image and text/audio input. This combines Text-to-Speech (TTS) with ElevenLabs and Lip Sync AI models via Replicate to create realistic avatar videos.

### Workflow Architecture

```
Prompt Node ──→ Text to Speech ──→ Audio
                                     ↓
Image Input ────────────────────→ Lip Sync ──→ Talking Head Video
```

### Tasks Completed

1. **Type Definitions** - Added TTSProvider, TTSVoice, TextToSpeechNodeData to packages/types
2. **TTS Service** - Created ElevenLabs integration with 40+ voice options
3. **Replicate Integration** - Added 4 lip-sync models (sync/lipsync-2-pro, sync/lipsync-2, bytedance/latentsync, pixverse/lipsync)
4. **FFmpeg Voice Change** - Added replaceAudio method for audio mixing
5. **Queue Processing** - Added lipSync, textToSpeech, voiceChange processor cases
6. **Frontend Components** - Created LipSyncNode, VoiceChangeNode, TextToSpeechNode
7. **API Key Warning** - TextToSpeechNode shows warning when ElevenLabs not configured
8. **Documentation** - Created comprehensive PRD at .agents/PRDS/avatar-workflow.md

### Files Created

```
apps/api/src/tts/tts.service.ts      # ElevenLabs TTS integration (40+ voices)
apps/api/src/tts/tts.module.ts       # NestJS module for TTS
apps/web/src/components/nodes/ai/LipSyncNode.tsx      # Lip sync node UI
apps/web/src/components/nodes/ai/VoiceChangeNode.tsx  # Voice change node UI
apps/web/src/components/nodes/ai/TextToSpeechNode.tsx # TTS node UI with API key warning
.agents/PRDS/avatar-workflow.md       # Full feature documentation
```

### Files Modified

```
packages/types/src/nodes.ts          # TTSProvider, TTSVoice, TextToSpeechNodeData, NODE_DEFINITIONS
apps/api/src/replicate/replicate.service.ts  # Added lip-sync models and generateLipSync()
apps/api/src/ffmpeg/ffmpeg.service.ts        # Added ReplaceAudioInput, replaceAudio()
apps/api/src/queue/processors/processing.processor.ts  # lipSync, textToSpeech, voiceChange cases
apps/api/src/queue/interfaces/job-data.interface.ts    # Job data interfaces
apps/api/src/queue/queue.constants.ts        # Node type to queue mapping
apps/api/src/queue/queue.module.ts           # Import TTSModule
apps/api/src/app.module.ts                   # Import TTSModule
apps/web/src/components/nodes/ai/index.ts    # Export new components
apps/web/src/components/nodes/index.ts       # Register in nodeTypes
apps/web/src/components/nodes/BaseNode.tsx   # Added Mic, AudioLines, Volume2 icons
apps/web/src/store/executionStore.ts         # Handle new node types
apps/web/.env.example                        # Added NEXT_PUBLIC_TTS_ENABLED
apps/api/.env.example                        # Added ELEVENLABS_API_KEY
```

### Technical Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| TTS Provider | ElevenLabs | High quality voices, well-documented API |
| Feature flag | NEXT_PUBLIC_TTS_ENABLED | Allows UI to show warning when not configured |
| Lip-sync models | 4 options | Different quality/cost tradeoffs for users |
| Voice change | FFmpeg-based | No external API needed for audio mixing |
| Audio output | Base64 data URL | Consistent with existing media handling |

### Lip Sync Models

| Model | Provider | Quality |
|-------|----------|---------|
| sync/lipsync-2-pro | Sync Labs | Highest |
| sync/lipsync-2 | Sync Labs | High |
| bytedance/latentsync | ByteDance | Good |
| pixverse/lipsync | Pixverse | Good |

### Configuration Required

**API** (`apps/api/.env`):
```bash
ELEVENLABS_API_KEY=your_key_here
```

**Web** (`apps/web/.env.local`):
```bash
NEXT_PUBLIC_TTS_ENABLED=true
```

### Requirements

- ElevenLabs API key for TTS
- FFmpeg installed for voice change node
- Replicate API key (already configured) for lip sync

### Open Issues

- TypeScript warning in processing.processor.ts:49 - `prediction` implicitly has `any` type (non-blocking)

---

## Session 5: node-banana Fork Evaluation

### Summary
Evaluated the node-banana fork at `/Users/decod3rs/www/vincentshipsit/forks/node-banana` and PR #31 from shrimbly/node-banana to determine what features are worth porting to genfeed core.

### Tasks Completed

1. **PR #31 Analysis** - Reviewed multi-agent sprint v0.2.0 PR
2. **Fork Commits Analysis** - Evaluated recent commits for quality and applicability
3. **Feature Comparison** - Compared node-banana vs genfeed core architectures
4. **Keyboard Shortcuts Analysis** - Identified portable feature
5. **Race Condition Fix Analysis** - Determined not applicable to genfeed core

### Findings

#### PR #31 (shrimbly/node-banana) - SKIP

| Aspect | Details |
|--------|---------|
| Status | Open, unmerged |
| Author | AI-generated (Jetpack multi-agent system) |
| Features | 7 new nodes, template gallery, undo/redo |
| Critical bugs | Duplicate `loop` case, RGB overflow, broken loop handler, pan delta loss |
| Recommendation | **Do not merge** - has unresolved code review issues |

#### Fork Recent Commits - SOLID

| Commit | Feature | Quality |
|--------|---------|---------|
| `8a2ed02` | Image history race condition fix | ✅ Good (net -51 lines) |
| `7e8c925` | Node defaults infrastructure | ✅ Good (216 lines of tests) |
| `bb37de3` | Shift+V shortcut for video | ✅ Good (small, clean) |
| `ccdd550` + `1278cd2` | Model selection UI | ✅ Good |

#### Feature Comparison

| Feature | node-banana | genfeed core | Worth porting? |
|---------|-------------|--------------|----------------|
| Node defaults (default models) | ✅ | ✅ Already has | No |
| localStorage persistence | ✅ | ✅ Already has | No |
| Recent models tracking | ✅ | ✅ Already has | No |
| Node creation shortcuts (Shift+V) | ✅ | ❌ Missing | **Yes** |
| Image history race condition fix | ✅ | N/A (different arch) | **No** |

### Technical Analysis

#### Keyboard Shortcuts (PORTABLE)

node-banana implementation:
```typescript
case "g": nodeType = "nanoBanana"; break;      // Shift+G → Image gen
case "v": nodeType = "generateVideo"; break;   // Shift+V → Video gen
case "l": nodeType = "llmGenerate"; break;     // Shift+L → LLM
```

genfeed core currently only has lock/group shortcuts (L, Ctrl+G, Ctrl+Shift+G).

#### Race Condition Fix (NOT APPLICABLE)

**Why it doesn't apply:**

| Aspect | node-banana | genfeed core |
|--------|-------------|--------------|
| Persistence | Local file system | API (`workflowsApi.create/update`) |
| Image storage | Externalized to folders | Inline in workflow data |
| History tracking | `imageHistory[]` with temp IDs | None |
| Save-generation API | Yes, async with ID syncing | No |

The race condition requires: local file saving + async ID syncing + externalization. Genfeed core uses API-based persistence, so this bug can't occur.

### Recommendations

1. **Keyboard shortcuts** - Worth porting to genfeed core (~10 line change)
2. **PR #31** - Skip entirely until properly fixed
3. **Other fork features** - Already exist in genfeed core or not applicable

### Files Analyzed

```
/Users/decod3rs/www/vincentshipsit/forks/node-banana/src/components/WorkflowCanvas.tsx
/Users/decod3rs/www/vincentshipsit/forks/node-banana/src/store/workflowStore.ts
/Users/decod3rs/www/genfeedai/core/apps/web/src/store/settingsStore.ts
/Users/decod3rs/www/genfeedai/core/apps/web/src/store/workflowStore.ts
/Users/decod3rs/www/genfeedai/core/apps/web/src/components/canvas/WorkflowCanvas.tsx
```

### No Files Modified

This was a research/analysis session only.

---

## Session 6: Environment File Cleanup

### Summary
Cleaned up redundant environment configuration files. Removed root `.env` and `.env.example`, consolidating all configuration to app-specific env files.

### Problem
The project had duplicate env files:
- Root `/.env` and `/.env.example` (redundant)
- `apps/api/.env` (actually used by NestJS)
- `apps/web/.env.local` (actually used by Next.js)

Scripts were updating both root and app-specific files, causing confusion about which was the source of truth.

### Solution
1. Deleted root `.env` and `.env.example`
2. Updated scripts to read from `apps/api/.env` only
3. Added missing variables to `apps/api/.env.example`

### Files Deleted

```
.env           # Redundant - duplicated apps/api/.env
.env.example   # Redundant - duplicated apps/api/.env.example
```

### Files Modified

```
scripts/dev-tunnel.ts           # Now only updates apps/api/.env (removed root .env from targets)
scripts/sync-replicate-schemas.ts  # Added explicit env loading from apps/api/.env
apps/api/.env.example           # Added STORAGE_ADAPTER, SQLITE_PATH vars
```

### Technical Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Remove root .env | Yes | Apps don't read from it, only scripts did |
| Scripts load from apps/api | Yes | Single source of truth for API tokens |
| Keep separate web/api envs | Yes | Different apps need different vars |

### New Environment Structure

| App | Env File | Purpose |
|-----|----------|---------|
| API (NestJS) | `apps/api/.env` | All backend config, API tokens |
| Web (Next.js) | `apps/web/.env.local` | Frontend public vars |
| Scripts | Load from `apps/api/.env` | Reuse API tokens |

### Patterns Established

- Scripts that need API tokens should explicitly load from `apps/api/.env`
- No root-level `.env` files in monorepo
- Each app maintains its own `.env.example` as documentation

---
