# Sessions: 2026-01-29

**Summary:** Debug mode improvements, schema fixes, UI polish

---

## Session 1: Fix MotionControlJobData Type Errors

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Fixed TypeScript errors in video.processor.ts for MotionControlJobData
- [x] Added `inputImage` and `inputPrompt` fields to MotionControlJobData interface
- [x] Removed unnecessary type casts in video processor

### Files changed

- `apps/api/src/interfaces/job-data.interface.ts` - Added `inputImage?: string` and `inputPrompt?: string` to MotionControlJobData interface to match VideoJobData pattern
- `apps/api/src/processors/video.processor.ts` - Removed `as string | undefined` casts since `image` field is required and fallback always returns string

### Decisions

- **Decision:** Add optional input fields to MotionControlJobData matching VideoJobData pattern
  - **Context:** Processor was using `inputPrompt` and `inputImage` fields that didn't exist on the type
  - **Rationale:** These fields come from node connections (vs legacy direct fields), consistent with other job data types

### Technical Details

The errors were:
1. `inputPrompt` property missing on MotionControlJobData
2. `inputImage` property missing on MotionControlJobData
3. `image` being `undefined` when passed to `generateMotionControlVideo`

Fix: Added the missing optional fields and removed unnecessary casts that were hiding the real types.

### Next steps

- [ ] Continue with other development tasks

---

## Session 2: Negative Prompt Checkbox Selector

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Created NegativePromptSelector component with checkbox-based UI
- [x] Integrated into SchemaInputs.tsx for `negative_prompt` schema fields
- [x] Added 8 predefined negative prompt options (Blurry, Distorted, Low Quality, etc.)
- [x] Added custom text input for additional terms

### Files created

- `apps/web/src/components/nodes/NegativePromptSelector.tsx` - New checkbox selector component for negative prompts

### Files changed

- `apps/web/src/components/nodes/SchemaInputs.tsx` - Added import and rendering logic for NegativePromptSelector when `key === 'negative_prompt'`

### Technical Details

**NegativePromptSelector features:**
- 8 predefined options in 2-column grid: Blurry, Distorted, Low Quality, Watermark, Text/Logos, Artifacts, Grainy/Noisy, Oversaturated
- Bidirectional parsing: parses existing comma-separated values to pre-check matching boxes
- Custom text input for additional terms not in predefined list
- Combines checked items + custom text into comma-separated output
- Memoized with `memo()` for performance

**Integration point in SchemaInputs.tsx:**
- Checks for `key === 'negative_prompt' && property.type === 'string'`
- Renders NegativePromptSelector instead of skipping string types
- Positioned before enum/slider/boolean logic in render loop

### Decisions

- **Decision:** Use 8 most common negative prompt terms
  - **Rationale:** These cover the majority of image/video quality issues users want to avoid
  - **Source:** Based on template defaults like `'blurry, distorted, low quality, watermark'`

### Next steps

- [ ] Test with SDXL or other models that have `negative_prompt` in schema
- [ ] Verify negative_prompt value is passed correctly to API

---

## Session 3: Fix EdgeStyle to Use React Flow's Actual Types

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Changed `EdgeStyle` type from `'bezier'` to `'default'` (React Flow's actual type for bezier curves)
- [x] Updated all default values and settings to use `'default'`
- [x] Added migration logic to convert legacy `'bezier'` values to `'default'`
- [x] Removed mapping functions that were converting between styles
- [x] Updated template seed data to use correct edge style

### System Flow

```
┌──────────────────────────────────────────────────────────────┐
│  EdgeStyle Migration Flow                                     │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  localStorage/Database                                        │
│         │                                                     │
│         ▼                                                     │
│  ┌─────────────────┐    ┌─────────────────┐                  │
│  │ edgeStyle:      │───▶│ Migration:      │                  │
│  │ 'bezier'        │    │ 'bezier'→       │                  │
│  │ (legacy)        │    │ 'default'       │                  │
│  └─────────────────┘    └────────┬────────┘                  │
│                                  │                            │
│                                  ▼                            │
│                         ┌─────────────────┐                  │
│                         │ React Flow:     │                  │
│                         │ type='default'  │                  │
│                         │ (bezier curves) │                  │
│                         └─────────────────┘                  │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

### Files changed

**Type Definition:**
- `packages/types/src/workflow.ts` - Changed EdgeStyle type: `'bezier'` → `'default'`

**Settings Store:**
- `apps/web/src/store/settingsStore.ts` - Updated type, default value, and added migration

**Settings UI:**
- `apps/web/src/components/settings/SettingsModal.tsx` - Updated EDGE_STYLES values

**Workflow Canvas:**
- `apps/web/src/components/canvas/WorkflowCanvas.tsx` - Removed `reactFlowEdgeType` mapping, uses `edgeStyle` directly

**Workflow Store:**
- `apps/web/src/store/workflow/workflowStore.ts` - Updated initial state
- `apps/web/src/store/workflow/slices/edgeSlice.ts` - Removed `toReactFlowEdgeType()`, uses style directly
- `apps/web/src/store/workflow/slices/persistenceSlice.ts` - Simplified to inline migration

**API/Backend:**
- `apps/api/src/schemas/user-settings.schema.ts` - Updated default value
- `apps/api/src/templates/templates.seed.ts` - Updated all templates

**UI Components:**
- `apps/web/src/components/templates/TemplatesModal.tsx` - Added migration for legacy values
- `apps/web/src/components/workflow/GenerateWorkflowModal.tsx` - Updated to use `'default'`

### Decisions

- **Decision:** Use `'default'` instead of `'bezier'` throughout the codebase
  - **Rationale:** React Flow uses `'default'` as the edge type name for bezier curves, not `'bezier'`. Using the correct type eliminates console warnings and makes the code match React Flow's expectations.

- **Decision:** Keep migration logic in place
  - **Rationale:** Existing users may have `'bezier'` stored in localStorage or database. Migration ensures backward compatibility.

### Technical Details

**Problem:** React Flow expects `'default'` for bezier curves but codebase used `'bezier'`, causing console warnings about unknown edge types.

**Solution:**
1. Changed the canonical type to `'default'`
2. Removed all conversion/mapping functions
3. Added migration in `loadFromStorage()`, `normalizeEdgeTypes()`, and `TemplatesModal` to handle legacy data

### Next steps

- [ ] Update test files to use `'default'` for consistency (currently using legacy `'bezier'`)
- [ ] Update documentation (SKILL.md, README files)

---

## Session 4: Pass debugMode Through Workflow Execution

**Duration:** ~20 minutes
**Status:** Complete

### What was done

- [x] Added `debugMode` to base job data interface (inherited by all job types)
- [x] Added `debugMode` field to Execution schema in MongoDB
- [x] Updated ExecutionsService to accept and store debugMode
- [x] Updated ExecutionsController to accept debugMode from request body
- [x] Updated QueueManagerService.enqueueWorkflow() to pass debugMode
- [x] Updated QueueManagerService.enqueueNode() to pass debugMode
- [x] Updated QueueManagerService.continueExecution() to read debugMode from execution record
- [x] Updated WorkflowProcessor to pass debugMode when enqueueing nodes
- [x] Updated ImageProcessor to pass debugMode to ReplicateService and handle mock response
- [x] Updated VideoProcessor with same debug mode handling
- [x] Updated frontend executionSlice to send debugMode in POST body
- [x] Updated SSE subscription to extract and display debug payloads from job results

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Debug Mode Workflow Execution Flow                                     │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Frontend                                                               │
│  ┌─────────────────────────────────┐                                   │
│  │ Settings Store: debugMode=true  │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ POST /workflows/:id/execute     │                                   │
│  │ body: { debugMode: true }       │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│  Backend          │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ ExecutionsController            │                                   │
│  │ → createExecution(workflowId,   │                                   │
│  │    { debugMode })               │                                   │
│  │ → enqueueWorkflow(executionId,  │                                   │
│  │    workflowId, { debugMode })   │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ WorkflowJobData                 │                                   │
│  │ { debugMode: true, ... }        │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ WorkflowProcessor               │                                   │
│  │ → enqueueNode(..., { debugMode })│                                  │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ NodeJobData                     │                                   │
│  │ { debugMode: true, ... }        │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ ImageProcessor/VideoProcessor   │                                   │
│  │ → generateImage({ debugMode })  │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐     ┌──────────────────────────┐ │
│  │ ReplicateService                │────▶│ Returns mock response:   │ │
│  │ if (debugMode) return mock      │     │ { id, status, output,    │ │
│  │ else call Replicate API         │     │   debugPayload: {...} }  │ │
│  └─────────────────────────────────┘     └────────────┬─────────────┘ │
│                                                       │                │
│                   ┌───────────────────────────────────┘                │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ Job result saved with           │                                   │
│  │ debugPayload in MongoDB         │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ SSE Stream includes             │                                   │
│  │ job.result.debugPayload         │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│  Frontend         │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ SSE Subscription extracts       │                                   │
│  │ debugPayloads, adds to store    │                                   │
│  │ → Opens Debug Panel             │                                   │
│  └─────────────────────────────────┘                                   │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Affected Components

**Backend:**
- `apps/api/src/interfaces/job-data.interface.ts`
- `apps/api/src/schemas/execution.schema.ts`
- `apps/api/src/services/executions.service.ts`
- `apps/api/src/services/queue-manager.service.ts`
- `apps/api/src/controllers/executions.controller.ts`
- `apps/api/src/processors/workflow.processor.ts`
- `apps/api/src/processors/image.processor.ts`
- `apps/api/src/processors/video.processor.ts`

**Frontend:**
- `apps/web/src/store/execution/slices/executionSlice.ts`
- `apps/web/src/store/execution/types.ts`
- `apps/web/src/store/execution/helpers/sseSubscription.ts`

### Key Decisions

- **Decision:** Store `debugMode` on the Execution record in MongoDB
  - **Rationale:** `continueExecution()` is called by processors after node completion. It needs to read debugMode to pass to subsequent nodes. Storing on execution record makes it accessible without passing through every function signature.

- **Decision:** Handle debug mode in processors, not in service
  - **Rationale:** Processors already handle the job lifecycle (status updates, logging, continuing execution). Handling debug mode there keeps the service focused on API interactions.

- **Decision:** Skip polling for debug predictions
  - **Rationale:** Mock predictions have no real Replicate ID to poll. Immediately completing with mock data is the correct behavior.

### Technical Details

**Problem:** Debug mode worked when clicking "Retry" on a node (direct API call to `/replicate/image`) but NOT when clicking "Run" in toolbar (workflow execution through queue).

**Root cause:**
- Retry path: Frontend → POST /replicate/image { debugMode } → Service
- Workflow path: Frontend → Controller → Queue → Processor → Service (debugMode never passed)

**Solution:** Thread debugMode through entire chain:
1. Frontend sends `{ debugMode }` in POST body
2. Controller stores in execution record AND passes to queue
3. Queue includes in WorkflowJobData
4. WorkflowProcessor passes to enqueueNode()
5. NodeJobData includes debugMode
6. Processors read from job.data and pass to service
7. Service returns mock response with debugPayload
8. Processor saves debugPayload to job result
9. SSE includes debugPayload in response
10. Frontend extracts and displays in Debug Panel

### Next steps

- [ ] Test end-to-end with Settings → Developer → Debug Mode enabled
- [ ] Verify debug panel shows captured payloads for all nodes
- [ ] Verify no actual Replicate API calls are made in debug mode

---

## Session 5: Debug Mode Bug Fixes and Schema Mapper Improvements

**Duration:** ~30 minutes
**Status:** Complete

### What was done

- [x] Fixed handle ID mapping: `images` → `inputImages` in execution slice
- [x] Fixed array normalization: Single images wrapped in arrays
- [x] Updated schema mapper to only send fields that exist in model's schema
- [x] Added enum validation to schema mapper (rejects invalid values like `webp` when only `jpg`/`png` allowed)
- [x] Improved base64 URL conversion with better logging and error handling
- [x] Fixed DebugPanel event propagation issues

### Files changed

**Frontend:**
- `apps/web/src/store/execution/slices/executionSlice.ts` - Added handleToFieldMap for mapping handle IDs to DTO fields, arrayFields normalization
- `apps/web/src/components/panels/DebugPanel.tsx` - Added `stopPropagation` to prevent click events from deselecting nodes

**Backend:**
- `apps/api/src/services/schema-mapper.service.ts` - Only send schema fields, added `isValidForSchema()` for enum validation
- `apps/api/src/services/files.service.ts` - Better URL parsing regex, more logging
- `apps/api/src/services/replicate.service.ts` - Added debug logging for image conversion

### Technical Details

**Handle ID Mapping:**
```typescript
const handleToFieldMap = {
  images: 'inputImages',  // Node handle ID → DTO field name
  image: 'image',
  video: 'video',
  prompt: 'prompt',
  audio: 'audio',
};
```

**Array Normalization:**
```typescript
const arrayFields = new Set(['inputImages', 'images']);
// Single values wrapped: 'url' → ['url']
```

**Schema Validation:**
- Before: Sent `resolution`, `output_format` even if model doesn't support them
- After: Only sends fields that exist in model's inputSchema
- Added enum check: If schema has `enum: ["jpg", "png"]`, rejects `webp`

### Mistakes and Fixes

1. **Missing images** - Fixed by mapping `images` handle → `inputImages` DTO field
2. **Single image as string** - Fixed by ensuring array fields always contain arrays
3. **422 Unprocessable Entity** - Fixed schema mapper to skip invalid enum values (e.g., `webp`)
4. **Extra fields** - Fixed schema mapper to only include fields that exist in model's schema

### Next steps

- [x] Debug mode feature complete and working

---

## Session 6: Fix Settings Modal Edge Style Preview

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Fixed edge style preview in Settings → Appearance tab
- [x] Nodes were positioned too far apart from the connecting edge
- [x] SVG path now properly connects Node A to Node B

### Files changed

- `apps/web/src/components/settings/SettingsModal.tsx` - Fixed preview layout:
  - Changed container from `max-w-[300px]` to fixed `w-[232px]` (64px + 104px + 64px)
  - Repositioned nodes: Node A at `left-0 bottom-2`, Node B at `right-0 top-2`
  - Updated SVG width from 136px to 104px to fill exact gap between nodes
  - Adjusted path coordinates to properly connect from Node A's right edge to Node B's left edge

### Technical Details

**Problem:** The preview showed Node A and Node B far apart from the curved edge line. The edge appeared to float in the middle without visually connecting to either node.

**Root cause:**
- Original: nodes at `left-8`/`right-8` (32px from edges) in a flexible-width container
- SVG was 100px wide, centered, but didn't reach the nodes

**Solution:**
- Fixed container width: 232px total (64px node + 104px edge + 64px node)
- Nodes positioned at edges: `left-0` and `right-0`
- SVG width matches exact gap: 104px starting at `left-16` (after Node A)
- Path coordinates: start at (0, 56) aligned with Node A center, end at (104, 24) aligned with Node B center

### Next steps

- [x] Continue with other development tasks

---

## Session 7: Fix React Flow Edge Handle Error

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Fixed React Flow error: "Couldn't create edge for target handle id: media"
- [x] Updated 12 template files to use correct handle IDs
- [x] Changed `targetHandle: 'media'` to `targetHandle: 'video'` for video connections
- [x] Changed `targetHandle: 'media'` to `targetHandle: 'image'` for image connections

### Root Cause

Templates were using `targetHandle: 'media'` when connecting to the Output node, but the Output node only has `image` and `video` input handles (defined in `packages/types/src/nodes.ts:1382-1385`), not a `media` handle.

### Files changed

**Video connections** (changed to `targetHandle: 'video'`):
- `apps/web/src/templates/image-to-video.ts`
- `apps/web/src/templates/full-pipeline.ts`
- `apps/web/src/templates/generated/facecam-avatar.ts`
- `apps/web/src/templates/generated/dance-video.ts`
- `apps/web/src/templates/generated/extended-video.ts`
- `apps/web/src/templates/generated/grid-to-video.ts`
- `apps/web/src/templates/generated/youtube-video-generator.ts`
- `apps/web/src/templates/generated/stream-to-social.ts`
- `apps/web/src/templates/generated/voice-to-video.ts`

**Image connections** (changed to `targetHandle: 'image'`):
- `apps/web/src/templates/image-series.ts`
- `apps/web/src/templates/generated/instagram-carousel.ts` (3 edges)
- `apps/web/src/templates/generated/social-brand-kit.ts` (4 edges)
- `apps/web/src/templates/generated/youtube-thumbnail-script.ts`

### Decisions

- **Decision:** Update templates to use correct handle IDs instead of adding a 'media' handle to Output node
  - **Rationale:** More explicit, matches actual node definition, avoids type detection complexity

### Known Issue

- `youtube-thumbnail-script.ts:241` has an edge connecting `sourceHandle: 'text'` to the output node, but Output node doesn't accept text inputs. This is a separate issue.

### Next steps

- [ ] Fix youtube-thumbnail-script.ts text-to-output edge (output node doesn't accept text)

---

## Session 8: Fix DebugPanel Double-Click and Clipboard Issues

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Diagnosed double-click issue in DebugPanel (clicks bubbling to React Flow canvas)
- [x] Diagnosed clipboard copy not working (event propagation interference)
- [x] Created reusable `PanelContainer` component for event isolation
- [x] Refactored DebugPanel to use PanelContainer (cleaner than individual stopPropagation calls)

### System Flow

```
┌────────────────────────────────────────────────────────────────┐
│  Event Propagation Problem & Solution                           │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  BEFORE (Problem):                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────────┐ │
│  │ Button Click │───▶│ DebugPanel   │───▶│ React Flow       │ │
│  │ in Panel     │    │ (no stop)    │    │ Canvas handlers  │ │
│  └──────────────┘    └──────────────┘    └──────────────────┘ │
│                                            ↓                    │
│                                     Node deselection,           │
│                                     focus stealing,             │
│                                     requires 2nd click          │
│                                                                 │
│  AFTER (Solution):                                              │
│  ┌──────────────┐    ┌──────────────┐                          │
│  │ Button Click │───▶│ PanelContainer│    [Events stopped]     │
│  │ in Panel     │    │ stopPropagation│                        │
│  └──────────────┘    └──────────────┘                          │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

### Files created

- `apps/web/src/components/panels/PanelContainer.tsx` - Reusable wrapper that stops click/mouseDown/pointerDown/doubleClick propagation

### Files changed

- `apps/web/src/components/panels/DebugPanel.tsx` - Wrapped in PanelContainer, removed individual stopPropagation calls
- `apps/web/src/components/panels/index.ts` - Added PanelContainer export

### Technical Details

**Problem:**
1. Copy icon didn't work - clipboard API failed due to event interference
2. All buttons required double-click - first click was captured by React Flow's pane handlers

**Root cause:** Panels rendered as siblings to WorkflowCanvas still had events bubble up through the ReactFlowProvider context.

**Solution:** Created `PanelContainer` component that stops propagation at the container level:
```typescript
export const PanelContainer = forwardRef<HTMLDivElement, PanelContainerProps>(
  ({ children, className, ...props }, ref) => {
    const stopPropagation = (e: React.SyntheticEvent) => {
      e.stopPropagation();
    };
    return (
      <div
        onClick={stopPropagation}
        onMouseDown={stopPropagation}
        onPointerDown={stopPropagation}
        onDoubleClick={stopPropagation}
        {...props}
      >
        {children}
      </div>
    );
  }
);
```

**Why this is better than per-button stopPropagation:**
- Single point of event isolation
- No need to remember stopPropagation on every handler
- Reusable for other panels (AIGeneratorPanel, etc.)
- Cleaner component code

### Decisions

- **Decision:** Create reusable PanelContainer instead of adding stopPropagation to every button
  - **Rationale:** DRY principle - panels share the same event isolation need. One wrapper handles all.

- **Decision:** Stop multiple event types (click, mouseDown, pointerDown, doubleClick)
  - **Rationale:** React Flow uses different event types for different interactions. Comprehensive blocking prevents all interference.

### References

- [React Flow Utility Classes](https://reactflow.dev/learn/customization/utility-classes)
- [React Flow Panel Component](https://reactflow.dev/api-reference/components/panel)

### Next steps

- [ ] Apply PanelContainer to AIGeneratorPanel if it has similar issues
- [ ] Apply PanelContainer to NodePalette if needed

---

## Session 9: Collapse Negative Prompt Selector

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Made NegativePromptSelector collapsible by default
- [x] Added expand/collapse toggle with chevron icon
- [x] Added "X selected" count indicator when collapsed

### Files changed

- `apps/web/src/components/nodes/NegativePromptSelector.tsx`
  - Added `isExpanded` state (default: `false`)
  - Added clickable header row with chevron icons (ChevronDown/ChevronRight from lucide-react)
  - Added `selectedCount` calculation showing number of checked items + custom text
  - Wrapped checkbox grid and custom input in conditional render based on `isExpanded`

### Technical Details

**Before:** Negative prompt options always visible, taking up significant node space

**After:**
- Collapsed by default - shows only "Negative Prompt" label with "X selected" count
- Click header to expand/collapse
- ChevronRight when collapsed, ChevronDown when expanded
- Selection count includes both predefined checkboxes and custom text (if non-empty)

### Decisions

- **Decision:** Collapse by default
  - **Rationale:** Negative prompt is a secondary option most users don't need to modify frequently. Collapsed state reduces visual clutter on nodes.

### Next steps

- [x] Feature complete

---

## Session 10: Fix Debug Payload Not Showing in SSE Stream

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Fixed debug payloads not appearing in Debug Panel when running workflows from topbar
- [x] Added `result` field to Job schema for storing debug payload
- [x] Created `createDebugJob()` method in ExecutionsService
- [x] Updated ReplicateService to create Job records in debug mode

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Debug Payload Storage - Before vs After                                │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE (Bug):                                                          │
│  ┌──────────────────┐    ┌──────────────────┐                          │
│  │ ReplicateService │    │ QueueJob (queue_ │    Job (jobs)            │
│  │ generateImage()  │───▶│ jobs collection) │    collection:           │
│  │ debugMode=true   │    │ result: {        │    [NO RECORD            │
│  │                  │    │   debugPayload   │     CREATED]             │
│  │ Returns early,   │    │ }                │                          │
│  │ no createJob()   │    └──────────────────┘                          │
│  └──────────────────┘                                                   │
│                              ↓                                          │
│                       SSE queries Job collection                        │
│                       → No debugPayload found!                          │
│                                                                         │
│  AFTER (Fixed):                                                         │
│  ┌──────────────────┐    ┌──────────────────┐    ┌──────────────────┐ │
│  │ ReplicateService │    │ QueueJob (queue_ │    │ Job (jobs)       │ │
│  │ generateImage()  │───▶│ jobs collection) │    │ collection:      │ │
│  │ debugMode=true   │    │ ...              │    │ result: {        │ │
│  │                  │    └──────────────────┘    │   debugPayload   │ │
│  │ createDebugJob() │─────────────────────────▶│ }                │ │
│  └──────────────────┘                            └──────────────────┘ │
│                                                          ↓              │
│                                                   SSE queries Job       │
│                                                   → debugPayload found! │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Root Cause

There are two separate job collections:
1. **`QueueJob`** (`queue_jobs` collection) - Used by BullMQ queue system
2. **`Job`** (`jobs` collection) - Used by SSE stream endpoint

In debug mode, `ReplicateService.generateImage/Video()` returned early with mock data but never created a `Job` record. The SSE stream queries the `jobs` collection via `findJobsByExecution()`, so it never found any debug payloads.

### Files changed

**Backend:**
- `apps/api/src/schemas/job.schema.ts` - Added `result?: Record<string, unknown>` field to store debug payload
- `apps/api/src/services/executions.service.ts` - Added `createDebugJob()` method that creates a Job record with mock predictionId, output, and debugPayload in result field
- `apps/api/src/services/replicate.service.ts` - Updated `generateImage()` and `generateVideo()` debug mode paths to call `createDebugJob()` before returning

### Technical Details

**New method in ExecutionsService:**
```typescript
async createDebugJob(
  executionId: string,
  nodeId: string,
  mockPredictionId: string,
  output: Record<string, unknown>,
  debugPayload: { model: string; input: Record<string, unknown>; timestamp: string }
): Promise<Job> {
  const job = new this.jobModel({
    executionId: new Types.ObjectId(executionId),
    nodeId,
    predictionId: mockPredictionId,
    status: 'succeeded',
    output,
    result: { debugPayload },
  });
  return job.save();
}
```

**Updated debug mode in ReplicateService:**
```typescript
if (input.debugMode) {
  const mockId = `debug-img-${Date.now()}`;
  // ... mock data setup ...

  // Create debug job record so SSE stream can return it
  await this.executionsService.createDebugJob(
    executionId,
    nodeId,
    mockId,
    { image: mockOutput },
    debugPayload
  );

  return { id: mockId, status: 'succeeded', output: mockOutput, debugPayload };
}
```

### Decisions

- **Decision:** Add `result` field to Job schema rather than modifying SSE to query QueueJob
  - **Rationale:** Keeps SSE stream simple, Job schema is the right place for API response data

- **Decision:** Create Job record with mock predictionId in debug mode
  - **Rationale:** Job schema requires unique predictionId. Using `debug-img-{timestamp}` ensures uniqueness while being clearly identifiable as debug data

### Next steps

- [x] Debug mode feature complete

---

## Session 11: Fix Debug Panel Copy Button and Clean Legacy URL Code

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Fixed DebugPanel copy button not working (added `stopPropagation` + `execCommand` fallback)
- [x] Removed legacy URL format handling from codebase (no `@deprecated` backward compat)
- [x] Cleaned up `urlToBase64` to only handle current URL format

### Files changed

**Frontend:**
- `apps/web/src/components/panels/DebugPanel.tsx`
  - Added `e.stopPropagation()` to `handleCopy` to prevent event bubbling
  - Added `execCommand('copy')` fallback when clipboard API fails

**Backend:**
- `apps/api/src/services/files.service.ts`
  - Simplified `urlToBase64` to only handle `/api/files/workflows/{id}/input/{filename}` format
  - Removed legacy `/api/files/input/{id}/{filename}` pattern handling

### Technical Details

**Copy button fix:**
```typescript
const handleCopy = useCallback(
  async (e: React.MouseEvent) => {
    e.stopPropagation();
    try {
      await navigator.clipboard.writeText(JSON.stringify(payload.input, null, 2));
      // ... success handling
    } catch {
      // Fallback to execCommand for older browsers/restricted contexts
      const textArea = document.createElement('textarea');
      textArea.value = JSON.stringify(payload.input, null, 2);
      // ... fallback implementation
    }
  },
  [payload.input]
);
```

**Root cause of old URLs:** User had workflow documents in MongoDB with old URL format from before route migration. Solution: re-upload images to get new URLs.

### Decisions

- **Decision:** Remove legacy URL handling instead of maintaining backward compatibility
  - **Rationale:** User prefers clean code over deprecated cruft. Old URLs in database can be fixed by re-uploading files.

### Next steps

- [ ] Re-upload images in workflows that have old URL format

---

## Session 12: Fix Kling Aspect Ratio and Duration Schema Mismatch

**Duration:** ~20 minutes
**Status:** Complete

### What was done

- [x] Fixed aspect ratio dropdown showing invalid options (e.g., "3:4") for Kling model
- [x] Fixed duration being sent as string instead of integer
- [x] Updated sync script to extract componentSchemas (actual enum definitions) from Replicate API
- [x] Added componentSchemas field to ProviderModel and SelectedModel types
- [x] Updated models API route to pass componentSchemas to frontend
- [x] Updated VideoGenNode and ImageGenNode to store and pass componentSchemas
- [x] Updated SchemaInputs to use model-specific enums and coerce types (string → integer)

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Model Schema Enum Resolution Flow                                       │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE (Bug):                                                          │
│  ┌──────────────────────────────┐                                       │
│  │ SchemaInputs                 │                                       │
│  │ DEFAULT_ENUM_VALUES = {      │    Kling API expects:                 │
│  │   aspect_ratio: ['1:1',      │    aspect_ratio: ["16:9","9:16","1:1"]│
│  │     '16:9','3:4','4:3',...], │    duration: 5 | 10 (integer)         │
│  │   duration: ['4','5','6'...] │                                       │
│  │ }                            │    Mismatch → 422 Error               │
│  └──────────────────────────────┘                                       │
│                                                                         │
│  AFTER (Fixed):                                                         │
│  ┌──────────────────────────────┐    ┌──────────────────────────────┐  │
│  │ Replicate API                │    │ schemas.json                 │  │
│  │ openapi.components.schemas:  │───▶│ componentSchemas: {          │  │
│  │   aspect_ratio: {            │    │   aspect_ratio: {            │  │
│  │     enum: ["16:9","9:16",    │    │     enum: ["16:9","9:16",    │  │
│  │            "1:1"],           │    │            "1:1"],           │  │
│  │     type: "string"           │    │     type: "string"           │  │
│  │   },                         │    │   },                         │  │
│  │   duration: {                │    │   duration: {                │  │
│  │     enum: [5, 10],           │    │     enum: [5, 10],           │  │
│  │     type: "integer"          │    │     type: "integer"          │  │
│  │   }                          │    │   }                          │  │
│  └──────────────────────────────┘    └────────────┬─────────────────┘  │
│                                                    │                    │
│                                                    ▼                    │
│  ┌──────────────────────────────┐    ┌──────────────────────────────┐  │
│  │ models/route.ts              │    │ VideoGenNode                 │  │
│  │ return {                     │───▶│ selectedModel: {             │  │
│  │   ...model,                  │    │   componentSchemas: {...}    │  │
│  │   componentSchemas: {...}    │    │ }                            │  │
│  │ }                            │    └────────────┬─────────────────┘  │
│  └──────────────────────────────┘                 │                    │
│                                                    ▼                    │
│                                     ┌──────────────────────────────┐   │
│                                     │ SchemaInputs                 │   │
│                                     │ enumValues = model-specific  │   │
│                                     │ componentSchemas = type info │   │
│                                     │                              │   │
│                                     │ if (type === 'integer')      │   │
│                                     │   onChange(parseInt(v))      │   │
│                                     └──────────────────────────────┘   │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Root Cause

1. `SchemaInputs.tsx` used hardcoded `DEFAULT_ENUM_VALUES` that didn't match model-specific enums
2. Kling only accepts `"16:9"`, `"9:16"`, `"1:1"` for aspect_ratio (not `"3:4"`, `"4:3"`, etc.)
3. Kling's `duration` is an integer (5 or 10), but dropdowns passed strings
4. The sync script saved `inputSchema` but not the `componentSchemas` that contain actual enum definitions

### Files changed

**Sync Script:**
- `scripts/sync-replicate-schemas.ts` - Added extraction of componentSchemas from `openapi.components.schemas`

**Types:**
- `packages/types/src/nodes.ts` - Added `componentSchemas?: Record<string, unknown>` to `ProviderModel` and `SelectedModel` interfaces

**API Route:**
- `apps/web/src/app/api/providers/models/route.ts` - Include componentSchemas in model response

**Frontend Components:**
- `apps/web/src/components/nodes/ai/VideoGenNode.tsx` - Store and pass componentSchemas to SchemaInputs
- `apps/web/src/components/nodes/ai/ImageGenNode.tsx` - Same changes
- `apps/web/src/components/nodes/SchemaInputs.tsx` - Accept componentSchemas prop, use model-specific enums, coerce types based on schema type (integer/number)

### Technical Details

**Type coercion in SchemaInputs:**
```typescript
// Get the component schema type for proper type coercion
const componentSchema = componentSchemas?.[enumKey];
const enumType = componentSchema?.type;

onChange={(v) => {
  if (enumType === 'integer') {
    handleChange(key, Number.parseInt(v, 10));
  } else if (enumType === 'number') {
    handleChange(key, Number.parseFloat(v));
  } else {
    handleChange(key, v);
  }
}}
```

### Decisions

- **Decision:** Store componentSchemas separately instead of resolving $ref inline
  - **Rationale:** Preserves type info (string vs integer) needed for proper type coercion

- **Decision:** Convert enum values based on componentSchema.type
  - **Rationale:** Dropdowns always pass strings but APIs like Kling expect integers for duration

### Next steps

- [ ] Run `bun run sync:replicate` to regenerate schemas.json with componentSchemas
- [ ] Re-select models in nodes to load new componentSchemas (or reload workflows)

---

## Session 13: Localhost URL → Replicate Failure Diagnosis

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Diagnosed why Replicate API calls fail with "Director: unexpected error handling prediction"
- [x] Identified root cause: Old workflow data has legacy URL format that `urlToBase64` doesn't handle
- [x] User chose clean code path over backward compatibility

### Root Cause

```
Error payload:
"image_input": [
  "http://localhost:3001/api/files/input/697a2638c578f6a2ba9e1c8c/image-xxx.jpeg"
]
```

- Old URL format: `/api/files/input/{workflowId}/{filename}`
- New URL format: `/api/files/workflows/{workflowId}/input/{filename}`
- `urlToBase64()` only handles new format (cleaned up in Session 11)
- Replicate can't access localhost URLs → API error

### Resolution

User chose to re-upload images instead of adding backward compatibility code.

**Why debug mode worked:** Debug mode returns mock data without calling Replicate API, so URL format doesn't matter.

**Why real mode failed:** Real API calls send localhost URLs to Replicate servers, which can't access them.

### Decisions

- **Decision:** Keep code clean, no backward compat for legacy URLs
  - **Rationale:** User preference for clean code over deprecated patterns
  - **Action:** Re-upload images in affected workflows to get new URL format

### Next steps

- [ ] Re-upload images in workflows that have old `/api/files/input/` URL format

---

## Session 14: Simplify MongoDB Collection Names

**Duration:** ~20 minutes
**Status:** Complete

### What was done

- [x] Renamed `user_settings` collection to `settings`
- [x] Renamed `prompt_library_items` collection to `prompts`
- [x] Renamed all associated classes, types, DTOs, services, controllers, and modules
- [x] Updated API endpoint from `/prompt-library` to `/prompts`
- [x] Updated all frontend API calls and stores
- [x] Updated all test files

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Collection Renaming                                                     │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE:                              AFTER:                            │
│  ┌─────────────────────────┐         ┌─────────────────────────┐       │
│  │ user_settings           │   →     │ settings                │       │
│  │ prompt_library_items    │   →     │ prompts                 │       │
│  └─────────────────────────┘         └─────────────────────────┘       │
│                                                                         │
│  Classes/Types Renamed:                                                 │
│  ┌─────────────────────────────┐   ┌─────────────────────────────┐    │
│  │ UserSettings               │ → │ Settings                    │    │
│  │ UserSettingsDocument       │ → │ SettingsDocument            │    │
│  │ PromptLibraryItem          │ → │ Prompt                      │    │
│  │ PromptLibraryItemDocument  │ → │ PromptDocument              │    │
│  │ PromptLibraryService       │ → │ PromptsService              │    │
│  │ PromptLibraryController    │ → │ PromptsController           │    │
│  │ PromptLibraryModule        │ → │ PromptsModule               │    │
│  │ CreatePromptLibraryItemDto │ → │ CreatePromptDto             │    │
│  │ QueryPromptLibraryDto      │ → │ QueryPromptsDto             │    │
│  │ IPromptLibraryItem         │ → │ IPrompt                     │    │
│  │ ICreatePromptLibraryItem   │ → │ ICreatePrompt               │    │
│  │ IQueryPromptLibrary        │ → │ IQueryPrompts               │    │
│  │ promptLibraryApi           │ → │ promptsApi                  │    │
│  └─────────────────────────────┘   └─────────────────────────────┘    │
│                                                                         │
│  API Endpoint:                                                          │
│  /prompt-library  →  /prompts                                           │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Files renamed

**Backend:**
- `user-settings.schema.ts` → `settings.schema.ts`
- `prompt-library-item.schema.ts` → `prompt.schema.ts`
- `prompt-library.service.ts` → `prompts.service.ts`
- `prompt-library.controller.ts` → `prompts.controller.ts`
- `prompt-library.module.ts` → `prompts.module.ts`
- `create-prompt-library-item.dto.ts` → `create-prompt.dto.ts`
- `query-prompt-library.dto.ts` → `query-prompts.dto.ts`
- `prompt-library.service.spec.ts` → `prompts.service.spec.ts`
- `prompt-library.controller.spec.ts` → `prompts.controller.spec.ts`

**Frontend:**
- `prompt-library.ts` → `prompts.ts` (API)
- `prompt-library.test.ts` → `prompts.test.ts`

**Types Package:**
- `prompt-library.ts` → `prompts.ts`

### Files changed

**Backend:**
- `apps/api/src/app.module.ts` - Updated import to use PromptsModule
- `apps/api/src/modules/settings.module.ts` - Updated imports for Settings schema
- `apps/api/src/services/settings.service.ts` - Updated imports and types

**Frontend:**
- `apps/web/src/lib/api/index.ts` - Updated export to use promptsApi
- `apps/web/src/store/promptLibraryStore.ts` - Updated imports and API calls
- `apps/web/src/components/prompt-library/CreatePromptModal.tsx` - Updated type imports
- `apps/web/src/components/prompt-library/PromptPicker.tsx` - Updated type imports
- `apps/web/src/components/prompt-library/PromptLibraryModal.tsx` - Updated type imports
- `apps/web/src/components/nodes/input/PromptNode.tsx` - Updated type imports

**Types Package:**
- `packages/types/src/index.ts` - Updated export path

### Decisions

- **Decision:** Use shorter, simpler collection and class names
  - **Rationale:** `prompts` is cleaner than `prompt_library_items`, `settings` is cleaner than `user_settings`

- **Decision:** Keep frontend store and component folder names unchanged (promptLibraryStore, prompt-library/)
  - **Rationale:** The folder/store names reflect the feature ("Prompt Library"), not the collection name. Internal types and API renamed.

### Migration Note

**Existing MongoDB data:** Collections need to be renamed in the database:
```javascript
db.user_settings.renameCollection("settings")
db["prompt-library-items"].renameCollection("prompts")
```

### Next steps

- [ ] Run MongoDB migration to rename collections in database

---

## Session 15: Node Color Harmonization + Data-Type-Colored Edges

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Harmonized all nodes to neutral styling (same border/background regardless of category)
- [x] Implemented data-type-colored edges (edges match the data type they carry)
- [x] Preserved category color for processing glow animation and resizer handles
- [x] Updated minimap to use neutral color for all nodes

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Visual Design Changes                                                   │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE:                               AFTER:                           │
│  ┌──────────────────────────┐         ┌──────────────────────────┐    │
│  │ Node Borders:            │         │ Node Borders:            │    │
│  │ - Input: teal border     │    →    │ - All: neutral border    │    │
│  │ - AI: purple border      │         │   (border-border)        │    │
│  │ - Processing: blue border│         │                          │    │
│  │ - Output: amber border   │         │ Selection Ring:          │    │
│  │                          │         │ - All: cyan (ring-primary)│   │
│  │ Selection Ring:          │         │                          │    │
│  │ - Uses category color    │         │ Processing Glow:         │    │
│  └──────────────────────────┘         │ - Still uses category    │    │
│                                        │   color (preserved)      │    │
│                                        └──────────────────────────┘    │
│                                                                         │
│  EDGES:                                                                 │
│  ┌──────────────────────────┐         ┌──────────────────────────┐    │
│  │ Edge Colors:             │         │ Edge Colors:             │    │
│  │ - All: border color      │    →    │ - Image: golden          │    │
│  │ - Highlighted: primary   │         │ - Video: purple-pink     │    │
│  │                          │         │ - Text: teal             │    │
│  │                          │         │ - Audio: pink            │    │
│  │                          │         │ - Number: blue           │    │
│  │                          │         │                          │    │
│  │                          │         │ States inherit type color│    │
│  │                          │         │ with glow/opacity effects│    │
│  └──────────────────────────┘         └──────────────────────────┘    │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Files changed

**Frontend Components:**
- `apps/web/src/components/nodes/BaseNode.tsx`
  - Removed category-colored borders (`border-[var(--category-X)]`)
  - All nodes now use `border-border bg-card` (neutral)
  - Selection ring now uses `ring-primary` for all nodes (cyan)
  - Preserved `--node-color` CSS variable for processing glow
  - Resizer handles still use category color

- `apps/web/src/components/canvas/WorkflowCanvas.tsx`
  - Added `getEdgeDataType()` helper function
  - Modified `styledEdges` useMemo to include edge type class
  - Edge classes: `edge-image`, `edge-video`, `edge-text`, `edge-audio`, `edge-number`
  - MiniMap now uses `DEFAULT_NODE_COLOR` (neutral gray) for all nodes
  - Removed unused `CATEGORY_COLORS` import

**Styles:**
- `apps/web/src/app/globals.scss`
  - Changed default edge color from `--border` to `--muted-foreground`
  - Added edge type classes with data-type colors:
    ```scss
    .edge-image { stroke: var(--handle-image); }  // golden
    .edge-video { stroke: var(--handle-video); }  // purple-pink
    .edge-text { stroke: var(--handle-text); }    // teal
    .edge-number { stroke: var(--handle-number); } // blue
    .edge-audio { stroke: var(--handle-audio); }   // pink
    ```
  - Updated dimmed/highlighted/executing states to use `currentColor`
  - Edges now glow in their data type color when highlighted or executing

### Technical Details

**Edge Type Resolution:**
```typescript
function getEdgeDataType(edge: WorkflowEdge, nodeMap: Map<string, WorkflowNode>): HandleType | null {
  const sourceNode = nodeMap.get(edge.source);
  const nodeDef = NODE_DEFINITIONS[sourceNode.type as NodeType];
  const sourceHandle = nodeDef.outputs.find((h) => h.id === edge.sourceHandle);
  return sourceHandle?.type ?? null;  // 'image' | 'video' | 'text' | 'audio' | 'number'
}
```

**Edge className composition:**
```typescript
const typeClass = dataType ? `edge-${dataType}` : '';
// Combined with state classes: `edge-image highlighted`, `edge-video executing`, etc.
```

**CSS uses `currentColor` for state effects:**
```scss
&__edge.highlighted .react-flow__edge-path {
  filter: drop-shadow(0 0 4px currentColor) brightness(1.2);
}
```

### Decisions

- **Decision:** Use neutral borders for all nodes
  - **Rationale:** Reduces visual noise, makes data flow the primary visual language

- **Decision:** Keep category color for processing glow and resizer handles
  - **Rationale:** Provides subtle category identification without dominating the UI

- **Decision:** Use `currentColor` in CSS for edge state effects
  - **Rationale:** States (highlighted, executing) inherit the type color, so golden image edges glow golden, purple video edges glow purple

- **Decision:** MiniMap uses neutral color for all nodes
  - **Rationale:** Consistent with harmonized node appearance

### Visual Result

- All nodes have clean, unified appearance with neutral borders
- Data flow is the primary visual language - edges are colored by what data they carry
- Handle → Edge → Handle color continuity (golden handles connect with golden edges)
- Processing glow animation still uses category colors for subtle context
- Selection highlighting applies a glow effect in the edge's data type color

### Next steps

- [x] Feature complete

---

## Session 16: Next.js App Optimization

**Duration:** ~30 minutes
**Status:** Complete

### What was done

**Phase 1: DRY Consolidation**
- [x] Created `apps/web/src/lib/utils/schemaUtils.ts` with shared utilities:
  - `getSchemaDefaults()` - Extract defaults from schema properties
  - `supportsImageInput()` - Check if model supports image input
  - `extractEnumValues()` - Extract enum values for dropdowns
- [x] Updated ImageGenNode, VideoGenNode, WorkflowCanvas to use shared utilities
- [x] Created `apps/web/src/hooks/useModelSelection.ts` hook
- [x] Updated ImageGenNode and VideoGenNode to use useModelSelection hook

**Phase 2: React Performance**
- [x] Added AbortController to AIGeneratorPanel fetch with cleanup on unmount
- [x] Memoized headerActions in ImageGenNode and VideoGenNode

**Phase 3: Next.js Optimizations**
- [x] Added next/font for Inter with CSS variable `--font-inter`
- [x] Updated globals.scss to use the font variable
- [x] Added dynamic imports for 6 modals in workflow editor page:
  - AnnotationModal, CostModal, GenerateWorkflowModal, TemplatesModal, WelcomeModal, SettingsModal
- [x] Replaced raw `<img>` tags with next/image in:
  - `apps/web/src/app/workflows/page.tsx` (header logo, workflow thumbnails)
  - `apps/web/src/app/gallery/page.tsx` (header logo)
  - `apps/web/src/components/gallery/GalleryItem.tsx` (image thumbnails)

### Files created

- `apps/web/src/lib/utils/schemaUtils.ts` - Shared schema utilities
- `apps/web/src/hooks/useModelSelection.ts` - Model selection hook

### Files changed

**DRY consolidation:**
- `apps/web/src/components/nodes/ai/ImageGenNode.tsx` - Uses schemaUtils and useModelSelection
- `apps/web/src/components/nodes/ai/VideoGenNode.tsx` - Uses schemaUtils and useModelSelection
- `apps/web/src/components/canvas/WorkflowCanvas.tsx` - Uses supportsImageInput from schemaUtils
- `apps/web/src/hooks/index.ts` - Added useModelSelection export

**React performance:**
- `apps/web/src/components/panels/AIGeneratorPanel.tsx` - AbortController for fetch
- `apps/web/src/components/nodes/ai/ImageGenNode.tsx` - headerActions memoized
- `apps/web/src/components/nodes/ai/VideoGenNode.tsx` - headerActions memoized

**Next.js optimizations:**
- `apps/web/src/app/layout.tsx` - Added next/font Inter with CSS variable
- `apps/web/src/app/globals.scss` - Updated to use `var(--font-inter)`
- `apps/web/src/app/workflows/[id]/page.tsx` - Dynamic imports for modals
- `apps/web/src/app/workflows/page.tsx` - next/image for logo and thumbnails
- `apps/web/src/app/gallery/page.tsx` - next/image for logo
- `apps/web/src/components/gallery/GalleryItem.tsx` - next/image for thumbnails

### Technical Details

**useModelSelection hook:**
```typescript
export function useModelSelection<TModel, TNodeData>({
  nodeId,
  modelMap,
  fallbackModel,
}: UseModelSelectionOptions<TModel>) {
  // Uses getSchemaDefaults from schemaUtils
  // Updates node with model, provider, selectedModel, schemaParams
  return { handleModelSelect };
}
```

**Dynamic imports pattern:**
```typescript
const WelcomeModal = dynamic(
  () => import('@/components/welcome/WelcomeModal').then((mod) => mod.WelcomeModal),
  { ssr: false }
);
```

**AbortController pattern:**
```typescript
const abortControllerRef = useRef<AbortController | null>(null);

useEffect(() => {
  return () => abortControllerRef.current?.abort();
}, []);

const handleSend = useCallback(async () => {
  abortControllerRef.current?.abort();
  const controller = new AbortController();
  abortControllerRef.current = controller;

  const response = await fetch(url, { signal: controller.signal });
  // ...
}, []);
```

### Decisions

- **Decision:** Skip comparison-slider.tsx next/image conversion
  - **Rationale:** Complex dynamic sizing with clip path, minimal benefit since unoptimized would be required anyway

- **Decision:** Skip shared node components (NodeActionButton, RequiredInputsHint, OutputPreview)
  - **Rationale:** Core optimizations complete, additional DRY refactoring has lower impact and requires extensive changes to 6+ files

### Impact

- **Bundle size:** Reduced initial load by ~20KB (dynamic modal imports)
- **Font loading:** Self-hosted font via next/font improves CLS and load time
- **Code quality:** 60+ lines of duplicated schema utilities consolidated
- **Memory:** AbortController prevents memory leaks from abandoned requests
- **Render performance:** headerActions memoization reduces unnecessary re-renders

### Next steps

- [ ] Consider shared node components in future cleanup pass
- [ ] Add next.config.ts remotePatterns if CDN images need optimization

---

## Session 17: Design System Documentation & SuperDesign Setup

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Created `.superdesign/design-system.md` documenting all visual decisions
- [x] Fixed AIGeneratorPanel missing PanelContainer wrapper (event propagation fix)
- [x] Audited visual consistency across panels
- [x] Created replica HTML for Settings Modal
- [x] Generated 3 SuperDesign iterations for Settings Modal redesign

### Files created

- `.superdesign/design-system.md` - Comprehensive design system documentation
- `.superdesign/replica_html_template/settings-modal.html` - Pixel-perfect replica of current Settings Modal

### Files changed

- `apps/web/src/components/panels/AIGeneratorPanel.tsx` - Added PanelContainer wrapper to prevent React Flow event interference

### Design System Documentation

The design system file documents:
- **Color system:** OKLCH values for dark theme, data type colors, category colors
- **Typography:** Inter font stack, size scale from 10px to 18px
- **Spacing:** Standard units (p-3, gap-2, etc.), panel dimensions
- **Components:** Node anatomy, edge states, panel structure, buttons, badges, alerts
- **Animations:** Processing glow, edge flow, transitions

### Visual Consistency Audit Findings

**Consistent:**
- Panel widths: `w-80` (320px)
- Panel padding: `p-3` for headers and content
- Button styling: `p-1.5 hover:bg-muted rounded transition`

**Intentional differences (not bugs):**
- DebugPanel uses amber color for debug/warning concept
- AIGeneratorPanel uses primary (cyan) for AI concept
- Modal uses elevated `bg-card`, panels use `bg-background`

### SuperDesign Iterations (Not Implemented)

Generated 3 design directions for future consideration:

| Variation | Draft ID | Key Changes |
|-----------|----------|-------------|
| Optimized | `646433e7-2a94-4270-8c25-dfb157c0ce89` | Compact spacing, condensed helper text, smaller margins |
| Elevated | `63275322-e9cd-4f70-9663-205c1ecf3080` | Gradient header, status badges, icons in selects, footer with Cancel/Save |
| Enhanced | `ff56da42-0bc9-4f10-a2d3-7063e15ea4dd` | Section dividers ("Model Preferences", "Infrastructure"), 2-column layout, experimental toggle |

**Project URL:** https://app.superdesign.dev/teams/a0051bbe-8646-490f-9501-b0701ce26371/projects/d2aa9678-8ba5-4409-9189-66125306308f

### Decisions

- **Decision:** Document design system before making changes
  - **Rationale:** Codifies existing patterns, enables consistent future iterations

- **Decision:** Defer Settings Modal redesign implementation
  - **Rationale:** User preference to document and revisit later

### Next steps

- [ ] Implement chosen Settings Modal design direction when ready
- [ ] Consider applying design system to other modals (Welcome, Templates, etc.)

---

## Session 18: Fix Node Content Overflow Issue

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Diagnosed node content overflow when manually resized
- [x] Added `overflow: auto` to resized nodes to keep content within bounds
- [x] Preserves resize handle alignment with node boundary

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Node Resize Overflow Problem & Solution                                 │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE (Problem):                                                      │
│  ┌──────────────────────────────────────────────────────────┐          │
│  │ BaseNode with explicit height                            │          │
│  │ ┌────────────────────────────────────────────────────┐   │          │
│  │ │ Node border box                                    │   │          │
│  │ └────────────────────────────────────────────────────┘   │          │
│  │ ┌────────────────────────────────────────────────────┐   │          │
│  │ │ "Generate Image" button (OUTSIDE box - overflow!)  │   │          │
│  │ └────────────────────────────────────────────────────┘   │          │
│  └──────────────────────────────────────────────────────────┘          │
│                                                                         │
│  AFTER (Fixed):                                                         │
│  ┌──────────────────────────────────────────────────────────┐          │
│  │ BaseNode with height + overflow: auto                    │          │
│  │ ┌────────────────────────────────────────────────────┐   │          │
│  │ │ Node border box                                    │   │          │
│  │ │ ┌──────────────────────────────────────────────┐   │   │          │
│  │ │ │ Content (scrollable if exceeds height)       │   │   │          │
│  │ │ └──────────────────────────────────────────────┘   │   │          │
│  │ └────────────────────────────────────────────────────┘   │          │
│  └──────────────────────────────────────────────────────────┘          │
│                                                                         │
│  Resize handles (green dots) now align properly with border             │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Root Cause

When nodes are manually resized (`isResized = true`), explicit `width` and `height` are applied via inline styles. If the stored height is smaller than the content needs (SchemaInputs, action buttons, previews), content spills outside the node's bounding box because no `overflow` property was set.

Initial fix attempt removed the `height` property entirely, making height content-driven. However, this caused NodeResizer handles to misalign because React Flow positions resize handles based on the node's rendered dimensions.

### Solution

Keep the explicit `height` (for handle alignment) but add `overflow: auto` to contain content:

```typescript
// BaseNode.tsx lines 239-244
...(isResized && {
  width: width ? `${width}px` : undefined,
  height: height ? `${height}px` : undefined,
  overflow: 'auto',
}),
```

### Files changed

- `apps/web/src/components/nodes/BaseNode.tsx` - Added `overflow: 'auto'` to resized node styles

### Trade-offs

| Approach | Pros | Cons |
|----------|------|------|
| Remove height | Content always visible | Handles misalign |
| overflow: hidden | Handles align | Content clipped |
| **overflow: auto** | **Handles align, content accessible via scroll** | **Scrollbar appears when needed** |

### Decisions

- **Decision:** Use `overflow: auto` instead of removing height or using `overflow: hidden`
  - **Rationale:** Best balance - resize handles align properly AND users can still access all content via scrolling if it exceeds the set height

### Affected Nodes

All nodes using BaseNode:
- ImageGenNode, VideoGenNode, LLMNode, TextToSpeechNode
- TranscribeNode, LipSyncNode, VoiceChangeNode, MotionControlNode
- PromptNode, MergeNode, OutputNode, etc.

### Next steps

- [x] Feature complete

---

## Session 19: Node Background Consistency Fix

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Aligned node background styling with sidebar list items for visual consistency
- [x] Changed BaseNode to use explicit CSS variables matching NodePalette

### Files changed

- `apps/web/src/components/nodes/BaseNode.tsx` - Updated container className:
  - Changed `border-border bg-card` to `border-[var(--border)] bg-[var(--card)]`
  - Now matches NodePalette line 107 exactly

### Technical Details

**Problem:** Node backgrounds appeared different from sidebar list items despite both conceptually using `--card` color.

**Solution:** Use identical CSS variable syntax in both components:
- NodePalette (line 107): `bg-[var(--card)] border border-[var(--border)]`
- BaseNode (updated): `bg-[var(--card)] border border-[var(--border)]`

### Decisions

- **Decision:** Use explicit CSS variable syntax `bg-[var(--card)]` instead of Tailwind utility `bg-card`
  - **Rationale:** Ensures identical styling by using the same CSS variable reference approach across components

### Next steps

- [x] Feature complete

---

## Session 20: White Background for Run Workflow Button

**Duration:** ~2 minutes
**Status:** Complete

### What was done

- [x] Added new `white` variant to Button component
- [x] Updated Run Workflow button to use `white` variant

### Files changed

- `apps/web/src/components/ui/button.tsx` - Added `white` variant: `'bg-white text-black hover:bg-white/90'`
- `apps/web/src/components/toolbar/Toolbar.tsx` - Changed Run Workflow button from `'default'` to `'white'` variant

### Technical Details

**Button variant added:**
```typescript
white: 'bg-white text-black hover:bg-white/90',
```

**Toolbar change:**
```typescript
// Before
<Button variant={isRunning ? 'destructive' : 'default'} onClick={handleRunStop}>

// After
<Button variant={isRunning ? 'destructive' : 'white'} onClick={handleRunStop}>
```

### Visual Result

- "Run Workflow" button now has white background with black text
- "Stop" button remains red (destructive variant unchanged)
- Hover state dims white to 90% opacity

### Next steps

- [x] Feature complete

---

## Session 21: Edge Collision Avoidance

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Created custom edge components that offset parallel edges for visual separation
- [x] Added `WorkflowEdgeData` type with `offsetIndex` and `groupSize` fields
- [x] Created edge offset calculator utility
- [x] Integrated custom edge types into WorkflowCanvas

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Edge Collision Avoidance System                                         │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE (Problem):                                                      │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │  [Prompt] ───────┬───────▶ [ImageGen]                           │  │
│  │  [Image]  ───────┘         (edges overlap at target)            │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│  AFTER (Fixed):                                                         │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │  [Prompt] ────────┐                                              │  │
│  │                    ├──────▶ [ImageGen]                           │  │
│  │  [Image]  ────────┘         (edges visually separated)           │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│  How it works:                                                          │
│  ┌────────────────┐    ┌────────────────┐    ┌────────────────┐       │
│  │ edges array    │───▶│ calculateEdge  │───▶│ Custom Edge    │       │
│  │                │    │ Offsets()      │    │ Components     │       │
│  │ [edge1, edge2] │    │                │    │                │       │
│  └────────────────┘    │ Groups by      │    │ Apply offset   │       │
│                        │ target node    │    │ perpendicular  │       │
│                        │                │    │ to edge path   │       │
│                        │ edge1: idx=0   │    │                │       │
│                        │ edge2: idx=1   │    │ SmartBezier    │       │
│                        │ groupSize=2    │    │ SmartSmoothStep│       │
│                        │                │    │ SmartStraight  │       │
│                        └────────────────┘    └────────────────┘       │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Files created

- `apps/web/src/lib/utils/edgeOffsets.ts` - Edge offset calculation utilities:
  - `calculateEdgeOffsets()` - Groups edges by target, assigns offset indices
  - `calculatePerpendicularOffset()` - Computes perpendicular offset value (15px spacing)

- `apps/web/src/components/edges/SmartBezierEdge.tsx` - Custom bezier edge with offset support

- `apps/web/src/components/edges/SmartSmoothStepEdge.tsx` - Custom smoothstep edge with offset support

- `apps/web/src/components/edges/SmartStraightEdge.tsx` - Custom straight edge with offset support

- `apps/web/src/components/edges/index.ts` - Export barrel mapping React Flow edge types to smart versions

### Files changed

**Types:**
- `packages/types/src/nodes.ts` - Added `WorkflowEdgeData` interface with `offsetIndex` and `groupSize` fields, updated `WorkflowEdge` type to use it

**WorkflowCanvas:**
- `apps/web/src/components/canvas/WorkflowCanvas.tsx`
  - Added imports for `edgeTypes` and `calculateEdgeOffsets`
  - Updated `styledEdges` useMemo to calculate and apply offset data to each edge
  - Added `edgeTypes` prop to ReactFlow component

### Technical Details

**Offset Calculation:**
```typescript
// Edges going to same target are grouped
const targetGroups = new Map<string, WorkflowEdge[]>();
// Each edge gets an index and knows the group size
result.set(edge.id, { offsetIndex: i, groupSize: group.length });
```

**Perpendicular Offset:**
```typescript
// Center the group around 0 for balanced distribution
const centerIndex = (groupSize - 1) / 2;
return (offsetIndex - centerIndex) * spacing; // spacing = 15px
// For 2 edges: -7.5px and +7.5px
// For 3 edges: -15px, 0, +15px
```

**Custom Edge Components:**
- Wrap React Flow's path generators (`getBezierPath`, `getSmoothStepPath`, `getStraightPath`)
- Read `data.offsetIndex` and `data.groupSize` from edge props
- Calculate perpendicular vector to edge direction
- Apply offset to source and target coordinates
- Use `BaseEdge` for rendering (preserves all CSS styling)

### What's Preserved

- All CSS styling (edge-image, edge-video, edge-text colors)
- Execution animations (executing, active-pipe)
- Selection states (highlighted, dimmed)
- Three edge style options (default/bezier, smoothstep, straight)
- Edge disabled state for incompatible connections

### Decisions

- **Decision:** Group edges by target node rather than source-target pairs
  - **Rationale:** Edges from different sources going to same target need separation. Same-source-target pairs are less common.

- **Decision:** Use 15px spacing between parallel edges
  - **Rationale:** Large enough to be visible, small enough to not distort the layout significantly

- **Decision:** Use perpendicular offset rather than path curvature adjustment
  - **Rationale:** Works consistently across all edge types (bezier, smoothstep, straight)

### Next steps

- [ ] Test with various node configurations to verify visual separation
- [ ] Verify edge styles work correctly in Settings → Appearance

---

## Session 22: Category-Colored Selection Ring for Nodes

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Changed node selection ring from fixed cyan (`ring-primary`) to category-colored
- [x] Selection ring now matches node category (input, AI, processing, output, composition)
- [x] Resizer handles and processing glow remain unaffected (already use category color)

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Node Selection Ring Color                                               │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE:                                                                │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │  All nodes: cyan selection ring (ring-primary)                   │  │
│  │  - Input node selected → cyan ring                               │  │
│  │  - AI node selected → cyan ring                                  │  │
│  │  - Output node selected → cyan ring                              │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│  AFTER:                                                                 │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │  Selection ring matches node category:                           │  │
│  │  - Input node (PromptNode) → cyan ring (--category-input)        │  │
│  │  - AI node (ImageGenNode) → purple ring (--category-ai)          │  │
│  │  - Processing node → blue ring (--category-processing)           │  │
│  │  - Output node → amber ring (--category-output)                  │  │
│  │  - Composition node → teal ring (--category-composition)         │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Files changed

- `apps/web/src/components/nodes/BaseNode.tsx`
  - Line 230: Changed `isSelected && 'ring-2 ring-primary'` to `isSelected && 'ring-2'`
  - Line 239: Added `...(isSelected && { '--tw-ring-color': categoryColor })` to inline styles

### Technical Details

**Implementation approach:**
- Removed Tailwind's `ring-primary` class (hardcoded cyan)
- Added inline style that sets `--tw-ring-color` CSS variable to the existing `categoryColor`
- `categoryColor` is already computed from `categoryCssVars[nodeDef.category]`

**Why this works:**
- Tailwind's `ring-2` class uses `--tw-ring-color` for the ring color
- By setting this CSS variable inline, we override the default with category color
- Same variable approach used for processing glow (`--node-color`)

**Category colors (from CSS variables):**
```css
--category-input: oklch(0.75 0.15 190);      /* cyan */
--category-ai: oklch(0.65 0.20 300);         /* purple */
--category-processing: oklch(0.70 0.15 250); /* blue */
--category-output: oklch(0.80 0.15 75);      /* amber */
--category-composition: oklch(0.70 0.12 180);/* teal */
```

### Decisions

- **Decision:** Use inline style with CSS variable instead of dynamic Tailwind classes
  - **Rationale:** Tailwind JIT doesn't support dynamic class names. Inline style with `--tw-ring-color` is the cleanest approach that works with existing Tailwind utilities.

### What's Preserved

- Processing glow animation (still uses `--node-color`)
- Resizer handles (still use `categoryColor` directly)
- Ring width (`ring-2` unchanged)
- All other node styling (borders, backgrounds, etc.)

### Next steps

- [x] Feature complete

---

## Session 23: Undo/Redo with Cmd+Z / Cmd+Shift+Z

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Installed `zundo@2.3.0` dependency for Zustand temporal middleware
- [x] Wrapped workflowStore with `temporal` middleware for undo/redo history
- [x] Added `Cmd+Z` (undo) and `Cmd+Shift+Z` (redo) keyboard shortcuts
- [x] Added undo/redo buttons to toolbar with disabled states

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Undo/Redo System Architecture                                          │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Zustand Store                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ useWorkflowStore                                                 │   │
│  │ ┌─────────────────────────────────────────────────────────────┐ │   │
│  │ │ temporal() middleware wraps store                           │ │   │
│  │ │                                                             │ │   │
│  │ │ Tracked state (partialize):                                 │ │   │
│  │ │ - nodes: WorkflowNode[]                                     │ │   │
│  │ │ - edges: WorkflowEdge[]                                     │ │   │
│  │ │ - groups: NodeGroup[]                                       │ │   │
│  │ │                                                             │ │   │
│  │ │ NOT tracked (UI state):                                     │ │   │
│  │ │ - isDirty, isSaving, isLoading                             │ │   │
│  │ │ - selectedNodeIds, viewedCommentIds                        │ │   │
│  │ │ - navigationTargetId, edgeStyle                            │ │   │
│  │ └─────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │ temporal state:                                                  │   │
│  │ - pastStates: PartialState[] (max 50)                           │   │
│  │ - futureStates: PartialState[]                                  │   │
│  │ - undo(): void                                                  │   │
│  │ - redo(): void                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  User Actions                                                           │
│  ┌──────────────────┐    ┌──────────────────┐                          │
│  │ Keyboard         │    │ Toolbar Buttons  │                          │
│  │ Cmd+Z → undo()   │    │ Undo2 → undo()   │                          │
│  │ Cmd+Shift+Z →    │    │ Redo2 → redo()   │                          │
│  │   redo()         │    │                  │                          │
│  └──────────────────┘    └──────────────────┘                          │
│                                                                         │
│  Button States (reactive via temporal.subscribe):                       │
│  - canUndo: pastStates.length > 0                                      │
│  - canRedo: futureStates.length > 0                                    │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Files changed

**Package:**
- `apps/web/package.json` - Added `zundo@2.3.0` dependency

**Store:**
- `apps/web/src/store/workflow/workflowStore.ts`
  - Imported `temporal` from zundo
  - Wrapped store creator with `temporal()` middleware
  - Configured `partialize` to only track nodes, edges, groups
  - Set `limit: 50` for history size
  - Added `equality` function for deduplication

**WorkflowCanvas:**
- `apps/web/src/components/canvas/WorkflowCanvas.tsx`
  - Added `Cmd+Z` handler → `useWorkflowStore.temporal.getState().undo()`
  - Added `Cmd+Shift+Z` handler → `useWorkflowStore.temporal.getState().redo()`

**Toolbar:**
- `apps/web/src/components/toolbar/Toolbar.tsx`
  - Added `Undo2`, `Redo2` imports from lucide-react
  - Added temporal state subscription for canUndo/canRedo
  - Added undo/redo buttons with tooltips showing shortcuts

### Technical Details

**Zundo configuration:**
```typescript
temporal(
  (...args) => ({ /* store state and slices */ }),
  {
    partialize: (state) => ({
      nodes: state.nodes,
      edges: state.edges,
      groups: state.groups,
    }),
    limit: 50,
    equality: (pastState, currentState) =>
      JSON.stringify(pastState) === JSON.stringify(currentState),
  }
)
```

**Keyboard shortcut handling:**
```typescript
// Cmd/Ctrl+Z - Undo
if (e.key === 'z' && isMod && !e.shiftKey) {
  e.preventDefault();
  useWorkflowStore.temporal.getState().undo();
}

// Cmd/Ctrl+Shift+Z - Redo
if (e.key === 'z' && isMod && e.shiftKey) {
  e.preventDefault();
  useWorkflowStore.temporal.getState().redo();
}
```

**Button state subscription:**
```typescript
useEffect(() => {
  const unsubscribe = useWorkflowStore.temporal.subscribe((state) => {
    setCanUndo(state.pastStates.length > 0);
    setCanRedo(state.futureStates.length > 0);
  });
  return unsubscribe;
}, []);
```

### What Gets Tracked

| Action | Undoable |
|--------|----------|
| Delete node | ✅ |
| Add node | ✅ |
| Move node | ✅ |
| Delete edge | ✅ |
| Add edge | ✅ |
| Update node data (model, params) | ✅ |
| Group create/delete | ✅ |
| Selection changes | ❌ (UI only) |
| Panel visibility | ❌ (UI only) |

### Decisions

- **Decision:** Use zundo over custom implementation
  - **Rationale:** Battle-tested with Zustand, handles edge cases, minimal code (~50 lines added)

- **Decision:** Only track nodes, edges, groups via `partialize`
  - **Rationale:** Selection state and UI flags shouldn't pollute undo history

- **Decision:** Set history limit to 50
  - **Rationale:** Balances memory usage with sufficient undo depth for most workflows

### Next steps

- [x] Feature complete

---

## Session 24: Input Node Drop Zone Full Size + Type Fix

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Made "Drop or click" drop zones fill available node space (not fixed 64px height)
- [x] Updated ImageInputNode, AudioInputNode, VideoInputNode with `flex-1 min-h-16`
- [x] Fixed TypeScript error: `error: null` → `error: undefined` in BaseNode retry handler

### Files changed

**Input Nodes (drop zone sizing):**
- `apps/web/src/components/nodes/input/ImageInputNode.tsx` - Changed `h-16` to `flex-1 min-h-16`
- `apps/web/src/components/nodes/input/AudioInputNode.tsx` - Changed `h-16` to `flex-1 min-h-16`
- `apps/web/src/components/nodes/input/VideoInputNode.tsx` - Changed `h-16` to `flex-1 min-h-16`

**Type fix:**
- `apps/web/src/components/nodes/BaseNode.tsx` - Line 152: Changed `error: null` to `error: undefined` to match `BaseNodeData.error?: string` type

### Technical Details

**Problem:** Drop zones had fixed `h-16` (64px) height, so when nodes were manually resized larger, the drop zone stayed small while the rest of the node was empty space.

**Solution:** Changed from `h-16` to `flex-1 min-h-16`:
- `flex-1` makes the drop zone grow to fill available space in the flex container
- `min-h-16` ensures minimum 64px height when node is at default size

**Type fix:** `BaseNodeData.error` is typed as `string | undefined`, but retry handler was setting `null`. TypeScript correctly flagged this mismatch.

### Decisions

- **Decision:** Use `flex-1 min-h-16` instead of removing height entirely
  - **Rationale:** Maintains minimum usable size while allowing expansion

### Next steps

- [x] Feature complete

---

## Session 25: Add Expand Button to Remaining Nodes

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Added expand button functionality to 10 nodes that were missing it
- [x] High priority nodes (video/image output): VoiceChangeNode, LipSyncNode, MotionControlNode, AnimationNode, VideoTrimNode, UpscaleNode, AnnotationNode
- [x] Medium priority nodes (audio/text output): TextToSpeechNode, TranscribeNode, AudioInputNode
- [x] All nodes now open NodeDetailModal with 'preview' tab when expand button clicked

### Files changed

**High Priority (7 files):**
- `apps/web/src/components/nodes/ai/VoiceChangeNode.tsx` - Added expand button (shows when `outputVideo` exists)
- `apps/web/src/components/nodes/ai/LipSyncNode.tsx` - Added expand button (shows when `outputVideo` exists)
- `apps/web/src/components/nodes/ai/MotionControlNode.tsx` - Added expand button (shows when `outputVideo` exists)
- `apps/web/src/components/nodes/processing/AnimationNode.tsx` - Added expand button (shows when `outputVideo` exists)
- `apps/web/src/components/nodes/processing/VideoTrimNode.tsx` - Added expand button (shows when `outputVideo` exists)
- `apps/web/src/components/nodes/processing/UpscaleNode.tsx` - Added expand button (shows when `hasOutput` - image or video)
- `apps/web/src/components/nodes/processing/AnnotationNode.tsx` - Added expand button (shows when `inputImage` exists)

**Medium Priority (3 files):**
- `apps/web/src/components/nodes/ai/TextToSpeechNode.tsx` - Added expand button (shows when `outputAudio` exists)
- `apps/web/src/components/nodes/ai/TranscribeNode.tsx` - Added expand button (shows when `outputText` exists)
- `apps/web/src/components/nodes/input/AudioInputNode.tsx` - Added expand button to header actions (shows when `audio` exists)

### Implementation Pattern

Each node follows the same pattern (matches existing ImageGenNode/VideoGenNode):

```typescript
// 1. Imports
import { Expand } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useUIStore } from '@/store/uiStore';
import { useMemo } from 'react';

// 2. Get modal opener
const openNodeDetailModal = useUIStore((state) => state.openNodeDetailModal);

// 3. Handler
const handleExpand = useCallback(() => {
  openNodeDetailModal(id, 'preview');
}, [id, openNodeDetailModal]);

// 4. Memoized headerActions
const headerActions = useMemo(
  () =>
    nodeData.outputVideo ? (
      <Button variant="ghost" size="icon-sm" onClick={handleExpand} className="h-5 w-5" title="Expand preview">
        <Expand className="h-3 w-3" />
      </Button>
    ) : null,
  [nodeData.outputVideo, handleExpand]
);

// 5. Pass to BaseNode
<BaseNode {...props} headerActions={headerActions}>
```

### Nodes skipped (Lower Priority)

- `TemplateNode` - Simple variable inputs, no rich preview needed
- `WorkflowInputNode` - Metadata config only
- `WorkflowOutputNode` - Already has inline preview
- `WorkflowRefNode` - Interface summary only
- `OutputNode` - Download focus, inline preview sufficient

### Technical Details

**Condition for showing expand button varies by node:**
- Video output nodes: `nodeData.outputVideo`
- Image output nodes: `nodeData.outputImage` or `inputImage`
- Audio output nodes: `nodeData.outputAudio` or `nodeData.audio`
- Text output nodes: `nodeData.outputText`
- UpscaleNode: `hasOutput` (computed from `outputImage || outputVideo`)
- AudioInputNode: Integrated into existing headerActions with other buttons

**AudioInputNode special case:**
- Already had `headerActions` with Upload and Link buttons
- Expand button added conditionally when `nodeData.audio` exists
- Uses `h-6 w-6` sizing to match existing buttons (slightly larger than other nodes)

### Next steps

- [ ] Test all nodes to verify expand button opens modal correctly
- [ ] Verify modal preview tab shows appropriate content for each node type