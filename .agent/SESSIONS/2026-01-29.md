# Sessions: 2026-01-29

**Summary:** Debug mode improvements, schema fixes, UI polish, output file save fix, AI influencer template, prompts library seeding, second image node fix, backend template seeding (11 new templates), text propagation fix (Prompt → TextToSpeech), "Run Selected" partial execution fix, group feature bugs (viewport transform & drag), output node preview dimensions, Replicate 429 rate limit fix, edge selection highlight fix, TTS→LipSync input propagation fix, upstream-only selection highlighting

---

## Session 1: Fix MotionControlJobData Type Errors

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Fixed TypeScript errors in video.processor.ts for MotionControlJobData
- [x] Added `inputImage` and `inputPrompt` fields to MotionControlJobData interface
- [x] Removed unnecessary type casts in video processor

### Files changed

- `apps/api/src/interfaces/job-data.interface.ts` - Added `inputImage?: string` and `inputPrompt?: string` to MotionControlJobData interface to match VideoJobData pattern
- `apps/api/src/processors/video.processor.ts` - Removed `as string | undefined` casts since `image` field is required and fallback always returns string

### Decisions

- **Decision:** Add optional input fields to MotionControlJobData matching VideoJobData pattern
  - **Context:** Processor was using `inputPrompt` and `inputImage` fields that didn't exist on the type
  - **Rationale:** These fields come from node connections (vs legacy direct fields), consistent with other job data types

### Technical Details

The errors were:
1. `inputPrompt` property missing on MotionControlJobData
2. `inputImage` property missing on MotionControlJobData
3. `image` being `undefined` when passed to `generateMotionControlVideo`

Fix: Added the missing optional fields and removed unnecessary casts that were hiding the real types.

### Next steps

- [ ] Continue with other development tasks

---

## Session 2: Negative Prompt Checkbox Selector

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Created NegativePromptSelector component with checkbox-based UI
- [x] Integrated into SchemaInputs.tsx for `negative_prompt` schema fields
- [x] Added 8 predefined negative prompt options (Blurry, Distorted, Low Quality, etc.)
- [x] Added custom text input for additional terms

### Files created

- `apps/web/src/components/nodes/NegativePromptSelector.tsx` - New checkbox selector component for negative prompts

### Files changed

- `apps/web/src/components/nodes/SchemaInputs.tsx` - Added import and rendering logic for NegativePromptSelector when `key === 'negative_prompt'`

### Technical Details

**NegativePromptSelector features:**
- 8 predefined options in 2-column grid: Blurry, Distorted, Low Quality, Watermark, Text/Logos, Artifacts, Grainy/Noisy, Oversaturated
- Bidirectional parsing: parses existing comma-separated values to pre-check matching boxes
- Custom text input for additional terms not in predefined list
- Combines checked items + custom text into comma-separated output
- Memoized with `memo()` for performance

**Integration point in SchemaInputs.tsx:**
- Checks for `key === 'negative_prompt' && property.type === 'string'`
- Renders NegativePromptSelector instead of skipping string types
- Positioned before enum/slider/boolean logic in render loop

### Decisions

- **Decision:** Use 8 most common negative prompt terms
  - **Rationale:** These cover the majority of image/video quality issues users want to avoid
  - **Source:** Based on template defaults like `'blurry, distorted, low quality, watermark'`

### Next steps

- [ ] Test with SDXL or other models that have `negative_prompt` in schema
- [ ] Verify negative_prompt value is passed correctly to API

---

## Session 3: Fix EdgeStyle to Use React Flow's Actual Types

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Changed `EdgeStyle` type from `'bezier'` to `'default'` (React Flow's actual type for bezier curves)
- [x] Updated all default values and settings to use `'default'`
- [x] Added migration logic to convert legacy `'bezier'` values to `'default'`
- [x] Removed mapping functions that were converting between styles
- [x] Updated template seed data to use correct edge style

### System Flow

```
┌──────────────────────────────────────────────────────────────┐
│  EdgeStyle Migration Flow                                     │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  localStorage/Database                                        │
│         │                                                     │
│         ▼                                                     │
│  ┌─────────────────┐    ┌─────────────────┐                  │
│  │ edgeStyle:      │───▶│ Migration:      │                  │
│  │ 'bezier'        │    │ 'bezier'→       │                  │
│  │ (legacy)        │    │ 'default'       │                  │
│  └─────────────────┘    └────────┬────────┘                  │
│                                  │                            │
│                                  ▼                            │
│                         ┌─────────────────┐                  │
│                         │ React Flow:     │                  │
│                         │ type='default'  │                  │
│                         │ (bezier curves) │                  │
│                         └─────────────────┘                  │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

### Files changed

**Type Definition:**
- `packages/types/src/workflow.ts` - Changed EdgeStyle type: `'bezier'` → `'default'`

**Settings Store:**
- `apps/web/src/store/settingsStore.ts` - Updated type, default value, and added migration

**Settings UI:**
- `apps/web/src/components/settings/SettingsModal.tsx` - Updated EDGE_STYLES values

**Workflow Canvas:**
- `apps/web/src/components/canvas/WorkflowCanvas.tsx` - Removed `reactFlowEdgeType` mapping, uses `edgeStyle` directly

**Workflow Store:**
- `apps/web/src/store/workflow/workflowStore.ts` - Updated initial state
- `apps/web/src/store/workflow/slices/edgeSlice.ts` - Removed `toReactFlowEdgeType()`, uses style directly
- `apps/web/src/store/workflow/slices/persistenceSlice.ts` - Simplified to inline migration

**API/Backend:**
- `apps/api/src/schemas/user-settings.schema.ts` - Updated default value
- `apps/api/src/templates/templates.seed.ts` - Updated all templates

**UI Components:**
- `apps/web/src/components/templates/TemplatesModal.tsx` - Added migration for legacy values
- `apps/web/src/components/workflow/GenerateWorkflowModal.tsx` - Updated to use `'default'`

### Decisions

- **Decision:** Use `'default'` instead of `'bezier'` throughout the codebase
  - **Rationale:** React Flow uses `'default'` as the edge type name for bezier curves, not `'bezier'`. Using the correct type eliminates console warnings and makes the code match React Flow's expectations.

- **Decision:** Keep migration logic in place
  - **Rationale:** Existing users may have `'bezier'` stored in localStorage or database. Migration ensures backward compatibility.

### Technical Details

**Problem:** React Flow expects `'default'` for bezier curves but codebase used `'bezier'`, causing console warnings about unknown edge types.

**Solution:**
1. Changed the canonical type to `'default'`
2. Removed all conversion/mapping functions
3. Added migration in `loadFromStorage()`, `normalizeEdgeTypes()`, and `TemplatesModal` to handle legacy data

### Next steps

- [ ] Update test files to use `'default'` for consistency (currently using legacy `'bezier'`)
- [ ] Update documentation (SKILL.md, README files)

---

## Session 4: Pass debugMode Through Workflow Execution

**Duration:** ~20 minutes
**Status:** Complete

### What was done

- [x] Added `debugMode` to base job data interface (inherited by all job types)
- [x] Added `debugMode` field to Execution schema in MongoDB
- [x] Updated ExecutionsService to accept and store debugMode
- [x] Updated ExecutionsController to accept debugMode from request body
- [x] Updated QueueManagerService.enqueueWorkflow() to pass debugMode
- [x] Updated QueueManagerService.enqueueNode() to pass debugMode
- [x] Updated QueueManagerService.continueExecution() to read debugMode from execution record
- [x] Updated WorkflowProcessor to pass debugMode when enqueueing nodes
- [x] Updated ImageProcessor to pass debugMode to ReplicateService and handle mock response
- [x] Updated VideoProcessor with same debug mode handling
- [x] Updated frontend executionSlice to send debugMode in POST body
- [x] Updated SSE subscription to extract and display debug payloads from job results

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Debug Mode Workflow Execution Flow                                     │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Frontend                                                               │
│  ┌─────────────────────────────────┐                                   │
│  │ Settings Store: debugMode=true  │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ POST /workflows/:id/execute     │                                   │
│  │ body: { debugMode: true }       │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│  Backend          │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ ExecutionsController            │                                   │
│  │ → createExecution(workflowId,   │                                   │
│  │    { debugMode })               │                                   │
│  │ → enqueueWorkflow(executionId,  │                                   │
│  │    workflowId, { debugMode })   │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ WorkflowJobData                 │                                   │
│  │ { debugMode: true, ... }        │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ WorkflowProcessor               │                                   │
│  │ → enqueueNode(..., { debugMode })│                                  │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ NodeJobData                     │                                   │
│  │ { debugMode: true, ... }        │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ ImageProcessor/VideoProcessor   │                                   │
│  │ → generateImage({ debugMode })  │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐     ┌──────────────────────────┐ │
│  │ ReplicateService                │────▶│ Returns mock response:   │ │
│  │ if (debugMode) return mock      │     │ { id, status, output,    │ │
│  │ else call Replicate API         │     │   debugPayload: {...} }  │ │
│  └─────────────────────────────────┘     └────────────┬─────────────┘ │
│                                                       │                │
│                   ┌───────────────────────────────────┘                │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ Job result saved with           │                                   │
│  │ debugPayload in MongoDB         │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ SSE Stream includes             │                                   │
│  │ job.result.debugPayload         │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│  Frontend         │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ SSE Subscription extracts       │                                   │
│  │ debugPayloads, adds to store    │                                   │
│  │ → Opens Debug Panel             │                                   │
│  └─────────────────────────────────┘                                   │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Affected Components

**Backend:**
- `apps/api/src/interfaces/job-data.interface.ts`
- `apps/api/src/schemas/execution.schema.ts`
- `apps/api/src/services/executions.service.ts`
- `apps/api/src/services/queue-manager.service.ts`
- `apps/api/src/controllers/executions.controller.ts`
- `apps/api/src/processors/workflow.processor.ts`
- `apps/api/src/processors/image.processor.ts`
- `apps/api/src/processors/video.processor.ts`

**Frontend:**
- `apps/web/src/store/execution/slices/executionSlice.ts`
- `apps/web/src/store/execution/types.ts`
- `apps/web/src/store/execution/helpers/sseSubscription.ts`

### Key Decisions

- **Decision:** Store `debugMode` on the Execution record in MongoDB
  - **Rationale:** `continueExecution()` is called by processors after node completion. It needs to read debugMode to pass to subsequent nodes. Storing on execution record makes it accessible without passing through every function signature.

- **Decision:** Handle debug mode in processors, not in service
  - **Rationale:** Processors already handle the job lifecycle (status updates, logging, continuing execution). Handling debug mode there keeps the service focused on API interactions.

- **Decision:** Skip polling for debug predictions
  - **Rationale:** Mock predictions have no real Replicate ID to poll. Immediately completing with mock data is the correct behavior.

### Technical Details

**Problem:** Debug mode worked when clicking "Retry" on a node (direct API call to `/replicate/image`) but NOT when clicking "Run" in toolbar (workflow execution through queue).

**Root cause:**
- Retry path: Frontend → POST /replicate/image { debugMode } → Service
- Workflow path: Frontend → Controller → Queue → Processor → Service (debugMode never passed)

**Solution:** Thread debugMode through entire chain:
1. Frontend sends `{ debugMode }` in POST body
2. Controller stores in execution record AND passes to queue
3. Queue includes in WorkflowJobData
4. WorkflowProcessor passes to enqueueNode()
5. NodeJobData includes debugMode
6. Processors read from job.data and pass to service
7. Service returns mock response with debugPayload
8. Processor saves debugPayload to job result
9. SSE includes debugPayload in response
10. Frontend extracts and displays in Debug Panel

### Next steps

- [ ] Test end-to-end with Settings → Developer → Debug Mode enabled
- [ ] Verify debug panel shows captured payloads for all nodes
- [ ] Verify no actual Replicate API calls are made in debug mode

---

## Session 5: Debug Mode Bug Fixes and Schema Mapper Improvements

**Duration:** ~30 minutes
**Status:** Complete

### What was done

- [x] Fixed handle ID mapping: `images` → `inputImages` in execution slice
- [x] Fixed array normalization: Single images wrapped in arrays
- [x] Updated schema mapper to only send fields that exist in model's schema
- [x] Added enum validation to schema mapper (rejects invalid values like `webp` when only `jpg`/`png` allowed)
- [x] Improved base64 URL conversion with better logging and error handling
- [x] Fixed DebugPanel event propagation issues

### Files changed

**Frontend:**
- `apps/web/src/store/execution/slices/executionSlice.ts` - Added handleToFieldMap for mapping handle IDs to DTO fields, arrayFields normalization
- `apps/web/src/components/panels/DebugPanel.tsx` - Added `stopPropagation` to prevent click events from deselecting nodes

**Backend:**
- `apps/api/src/services/schema-mapper.service.ts` - Only send schema fields, added `isValidForSchema()` for enum validation
- `apps/api/src/services/files.service.ts` - Better URL parsing regex, more logging
- `apps/api/src/services/replicate.service.ts` - Added debug logging for image conversion

### Technical Details

**Handle ID Mapping:**
```typescript
const handleToFieldMap = {
  images: 'inputImages',  // Node handle ID → DTO field name
  image: 'image',
  video: 'video',
  prompt: 'prompt',
  audio: 'audio',
};
```

**Array Normalization:**
```typescript
const arrayFields = new Set(['inputImages', 'images']);
// Single values wrapped: 'url' → ['url']
```

**Schema Validation:**
- Before: Sent `resolution`, `output_format` even if model doesn't support them
- After: Only sends fields that exist in model's inputSchema
- Added enum check: If schema has `enum: ["jpg", "png"]`, rejects `webp`

### Mistakes and Fixes

1. **Missing images** - Fixed by mapping `images` handle → `inputImages` DTO field
2. **Single image as string** - Fixed by ensuring array fields always contain arrays
3. **422 Unprocessable Entity** - Fixed schema mapper to skip invalid enum values (e.g., `webp`)
4. **Extra fields** - Fixed schema mapper to only include fields that exist in model's schema

### Next steps

- [x] Debug mode feature complete and working

---

## Session 6: Fix Settings Modal Edge Style Preview

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Fixed edge style preview in Settings → Appearance tab
- [x] Nodes were positioned too far apart from the connecting edge
- [x] SVG path now properly connects Node A to Node B

### Files changed

- `apps/web/src/components/settings/SettingsModal.tsx` - Fixed preview layout:
  - Changed container from `max-w-[300px]` to fixed `w-[232px]` (64px + 104px + 64px)
  - Repositioned nodes: Node A at `left-0 bottom-2`, Node B at `right-0 top-2`
  - Updated SVG width from 136px to 104px to fill exact gap between nodes
  - Adjusted path coordinates to properly connect from Node A's right edge to Node B's left edge

### Technical Details

**Problem:** The preview showed Node A and Node B far apart from the curved edge line. The edge appeared to float in the middle without visually connecting to either node.

**Root cause:**
- Original: nodes at `left-8`/`right-8` (32px from edges) in a flexible-width container
- SVG was 100px wide, centered, but didn't reach the nodes

**Solution:**
- Fixed container width: 232px total (64px node + 104px edge + 64px node)
- Nodes positioned at edges: `left-0` and `right-0`
- SVG width matches exact gap: 104px starting at `left-16` (after Node A)
- Path coordinates: start at (0, 56) aligned with Node A center, end at (104, 24) aligned with Node B center

### Next steps

- [x] Continue with other development tasks

---

## Session 7: Fix React Flow Edge Handle Error

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Fixed React Flow error: "Couldn't create edge for target handle id: media"
- [x] Updated 12 template files to use correct handle IDs
- [x] Changed `targetHandle: 'media'` to `targetHandle: 'video'` for video connections
- [x] Changed `targetHandle: 'media'` to `targetHandle: 'image'` for image connections

### Root Cause

Templates were using `targetHandle: 'media'` when connecting to the Output node, but the Output node only has `image` and `video` input handles (defined in `packages/types/src/nodes.ts:1382-1385`), not a `media` handle.

### Files changed

**Video connections** (changed to `targetHandle: 'video'`):
- `apps/web/src/templates/image-to-video.ts`
- `apps/web/src/templates/full-pipeline.ts`
- `apps/web/src/templates/generated/facecam-avatar.ts`
- `apps/web/src/templates/generated/dance-video.ts`
- `apps/web/src/templates/generated/extended-video.ts`
- `apps/web/src/templates/generated/grid-to-video.ts`
- `apps/web/src/templates/generated/youtube-video-generator.ts`
- `apps/web/src/templates/generated/stream-to-social.ts`
- `apps/web/src/templates/generated/voice-to-video.ts`

**Image connections** (changed to `targetHandle: 'image'`):
- `apps/web/src/templates/image-series.ts`
- `apps/web/src/templates/generated/instagram-carousel.ts` (3 edges)
- `apps/web/src/templates/generated/social-brand-kit.ts` (4 edges)
- `apps/web/src/templates/generated/youtube-thumbnail-script.ts`

### Decisions

- **Decision:** Update templates to use correct handle IDs instead of adding a 'media' handle to Output node
  - **Rationale:** More explicit, matches actual node definition, avoids type detection complexity

### Known Issue

- `youtube-thumbnail-script.ts:241` has an edge connecting `sourceHandle: 'text'` to the output node, but Output node doesn't accept text inputs. This is a separate issue.

### Next steps

- [ ] Fix youtube-thumbnail-script.ts text-to-output edge (output node doesn't accept text)

---

## Session 8: Fix DebugPanel Double-Click and Clipboard Issues

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Diagnosed double-click issue in DebugPanel (clicks bubbling to React Flow canvas)
- [x] Diagnosed clipboard copy not working (event propagation interference)
- [x] Created reusable `PanelContainer` component for event isolation
- [x] Refactored DebugPanel to use PanelContainer (cleaner than individual stopPropagation calls)

### System Flow

```
┌────────────────────────────────────────────────────────────────┐
│  Event Propagation Problem & Solution                           │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  BEFORE (Problem):                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────────┐ │
│  │ Button Click │───▶│ DebugPanel   │───▶│ React Flow       │ │
│  │ in Panel     │    │ (no stop)    │    │ Canvas handlers  │ │
│  └──────────────┘    └──────────────┘    └──────────────────┘ │
│                                            ↓                    │
│                                     Node deselection,           │
│                                     focus stealing,             │
│                                     requires 2nd click          │
│                                                                 │
│  AFTER (Solution):                                              │
│  ┌──────────────┐    ┌──────────────┐                          │
│  │ Button Click │───▶│ PanelContainer│    [Events stopped]     │
│  │ in Panel     │    │ stopPropagation│                        │
│  └──────────────┘    └──────────────┘                          │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

### Files created

- `apps/web/src/components/panels/PanelContainer.tsx` - Reusable wrapper that stops click/mouseDown/pointerDown/doubleClick propagation

### Files changed

- `apps/web/src/components/panels/DebugPanel.tsx` - Wrapped in PanelContainer, removed individual stopPropagation calls
- `apps/web/src/components/panels/index.ts` - Added PanelContainer export

### Technical Details

**Problem:**
1. Copy icon didn't work - clipboard API failed due to event interference
2. All buttons required double-click - first click was captured by React Flow's pane handlers

**Root cause:** Panels rendered as siblings to WorkflowCanvas still had events bubble up through the ReactFlowProvider context.

**Solution:** Created `PanelContainer` component that stops propagation at the container level:
```typescript
export const PanelContainer = forwardRef<HTMLDivElement, PanelContainerProps>(
  ({ children, className, ...props }, ref) => {
    const stopPropagation = (e: React.SyntheticEvent) => {
      e.stopPropagation();
    };
    return (
      <div
        onClick={stopPropagation}
        onMouseDown={stopPropagation}
        onPointerDown={stopPropagation}
        onDoubleClick={stopPropagation}
        {...props}
      >
        {children}
      </div>
    );
  }
);
```

**Why this is better than per-button stopPropagation:**
- Single point of event isolation
- No need to remember stopPropagation on every handler
- Reusable for other panels (AIGeneratorPanel, etc.)
- Cleaner component code

### Decisions

- **Decision:** Create reusable PanelContainer instead of adding stopPropagation to every button
  - **Rationale:** DRY principle - panels share the same event isolation need. One wrapper handles all.

- **Decision:** Stop multiple event types (click, mouseDown, pointerDown, doubleClick)
  - **Rationale:** React Flow uses different event types for different interactions. Comprehensive blocking prevents all interference.

### References

- [React Flow Utility Classes](https://reactflow.dev/learn/customization/utility-classes)
- [React Flow Panel Component](https://reactflow.dev/api-reference/components/panel)

### Next steps

- [ ] Apply PanelContainer to AIGeneratorPanel if it has similar issues
- [ ] Apply PanelContainer to NodePalette if needed

---

## Session 9: Collapse Negative Prompt Selector

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Made NegativePromptSelector collapsible by default
- [x] Added expand/collapse toggle with chevron icon
- [x] Added "X selected" count indicator when collapsed

### Files changed

- `apps/web/src/components/nodes/NegativePromptSelector.tsx`
  - Added `isExpanded` state (default: `false`)
  - Added clickable header row with chevron icons (ChevronDown/ChevronRight from lucide-react)
  - Added `selectedCount` calculation showing number of checked items + custom text
  - Wrapped checkbox grid and custom input in conditional render based on `isExpanded`

### Technical Details

**Before:** Negative prompt options always visible, taking up significant node space

**After:**
- Collapsed by default - shows only "Negative Prompt" label with "X selected" count
- Click header to expand/collapse
- ChevronRight when collapsed, ChevronDown when expanded
- Selection count includes both predefined checkboxes and custom text (if non-empty)

### Decisions

- **Decision:** Collapse by default
  - **Rationale:** Negative prompt is a secondary option most users don't need to modify frequently. Collapsed state reduces visual clutter on nodes.

### Next steps

- [x] Feature complete

---

## Session 10: Fix Debug Payload Not Showing in SSE Stream

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Fixed debug payloads not appearing in Debug Panel when running workflows from topbar
- [x] Added `result` field to Job schema for storing debug payload
- [x] Created `createDebugJob()` method in ExecutionsService
- [x] Updated ReplicateService to create Job records in debug mode

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Debug Payload Storage - Before vs After                                │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE (Bug):                                                          │
│  ┌──────────────────┐    ┌──────────────────┐                          │
│  │ ReplicateService │    │ QueueJob (queue_ │    Job (jobs)            │
│  │ generateImage()  │───▶│ jobs collection) │    collection:           │
│  │ debugMode=true   │    │ result: {        │    [NO RECORD            │
│  │                  │    │   debugPayload   │     CREATED]             │
│  │ Returns early,   │    │ }                │                          │
│  │ no createJob()   │    └──────────────────┘                          │
│  └──────────────────┘                                                   │
│                              ↓                                          │
│                       SSE queries Job collection                        │
│                       → No debugPayload found!                          │
│                                                                         │
│  AFTER (Fixed):                                                         │
│  ┌──────────────────┐    ┌──────────────────┐    ┌──────────────────┐ │
│  │ ReplicateService │    │ QueueJob (queue_ │    │ Job (jobs)       │ │
│  │ generateImage()  │───▶│ jobs collection) │    │ collection:      │ │
│  │ debugMode=true   │    │ ...              │    │ result: {        │ │
│  │                  │    └──────────────────┘    │   debugPayload   │ │
│  │ createDebugJob() │─────────────────────────▶│ }                │ │
│  └──────────────────┘                            └──────────────────┘ │
│                                                          ↓              │
│                                                   SSE queries Job       │
│                                                   → debugPayload found! │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Root Cause

There are two separate job collections:
1. **`QueueJob`** (`queue_jobs` collection) - Used by BullMQ queue system
2. **`Job`** (`jobs` collection) - Used by SSE stream endpoint

In debug mode, `ReplicateService.generateImage/Video()` returned early with mock data but never created a `Job` record. The SSE stream queries the `jobs` collection via `findJobsByExecution()`, so it never found any debug payloads.

### Files changed

**Backend:**
- `apps/api/src/schemas/job.schema.ts` - Added `result?: Record<string, unknown>` field to store debug payload
- `apps/api/src/services/executions.service.ts` - Added `createDebugJob()` method that creates a Job record with mock predictionId, output, and debugPayload in result field
- `apps/api/src/services/replicate.service.ts` - Updated `generateImage()` and `generateVideo()` debug mode paths to call `createDebugJob()` before returning

### Technical Details

**New method in ExecutionsService:**
```typescript
async createDebugJob(
  executionId: string,
  nodeId: string,
  mockPredictionId: string,
  output: Record<string, unknown>,
  debugPayload: { model: string; input: Record<string, unknown>; timestamp: string }
): Promise<Job> {
  const job = new this.jobModel({
    executionId: new Types.ObjectId(executionId),
    nodeId,
    predictionId: mockPredictionId,
    status: 'succeeded',
    output,
    result: { debugPayload },
  });
  return job.save();
}
```

**Updated debug mode in ReplicateService:**
```typescript
if (input.debugMode) {
  const mockId = `debug-img-${Date.now()}`;
  // ... mock data setup ...

  // Create debug job record so SSE stream can return it
  await this.executionsService.createDebugJob(
    executionId,
    nodeId,
    mockId,
    { image: mockOutput },
    debugPayload
  );

  return { id: mockId, status: 'succeeded', output: mockOutput, debugPayload };
}
```

### Decisions

- **Decision:** Add `result` field to Job schema rather than modifying SSE to query QueueJob
  - **Rationale:** Keeps SSE stream simple, Job schema is the right place for API response data

- **Decision:** Create Job record with mock predictionId in debug mode
  - **Rationale:** Job schema requires unique predictionId. Using `debug-img-{timestamp}` ensures uniqueness while being clearly identifiable as debug data

### Next steps

- [x] Debug mode feature complete

---

## Session 11: Fix Debug Panel Copy Button and Clean Legacy URL Code

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Fixed DebugPanel copy button not working (added `stopPropagation` + `execCommand` fallback)
- [x] Removed legacy URL format handling from codebase (no `@deprecated` backward compat)
- [x] Cleaned up `urlToBase64` to only handle current URL format

### Files changed

**Frontend:**
- `apps/web/src/components/panels/DebugPanel.tsx`
  - Added `e.stopPropagation()` to `handleCopy` to prevent event bubbling
  - Added `execCommand('copy')` fallback when clipboard API fails

**Backend:**
- `apps/api/src/services/files.service.ts`
  - Simplified `urlToBase64` to only handle `/api/files/workflows/{id}/input/{filename}` format
  - Removed legacy `/api/files/input/{id}/{filename}` pattern handling

### Technical Details

**Copy button fix:**
```typescript
const handleCopy = useCallback(
  async (e: React.MouseEvent) => {
    e.stopPropagation();
    try {
      await navigator.clipboard.writeText(JSON.stringify(payload.input, null, 2));
      // ... success handling
    } catch {
      // Fallback to execCommand for older browsers/restricted contexts
      const textArea = document.createElement('textarea');
      textArea.value = JSON.stringify(payload.input, null, 2);
      // ... fallback implementation
    }
  },
  [payload.input]
);
```

**Root cause of old URLs:** User had workflow documents in MongoDB with old URL format from before route migration. Solution: re-upload images to get new URLs.

### Decisions

- **Decision:** Remove legacy URL handling instead of maintaining backward compatibility
  - **Rationale:** User prefers clean code over deprecated cruft. Old URLs in database can be fixed by re-uploading files.

### Next steps

- [ ] Re-upload images in workflows that have old URL format

---

## Session 12: Fix Kling Aspect Ratio and Duration Schema Mismatch

**Duration:** ~20 minutes
**Status:** Complete

### What was done

- [x] Fixed aspect ratio dropdown showing invalid options (e.g., "3:4") for Kling model
- [x] Fixed duration being sent as string instead of integer
- [x] Updated sync script to extract componentSchemas (actual enum definitions) from Replicate API
- [x] Added componentSchemas field to ProviderModel and SelectedModel types
- [x] Updated models API route to pass componentSchemas to frontend
- [x] Updated VideoGenNode and ImageGenNode to store and pass componentSchemas
- [x] Updated SchemaInputs to use model-specific enums and coerce types (string → integer)

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Model Schema Enum Resolution Flow                                       │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE (Bug):                                                          │
│  ┌──────────────────────────────┐                                       │
│  │ SchemaInputs                 │                                       │
│  │ DEFAULT_ENUM_VALUES = {      │    Kling API expects:                 │
│  │   aspect_ratio: ['1:1',      │    aspect_ratio: ["16:9","9:16","1:1"]│
│  │     '16:9','3:4','4:3',...], │    duration: 5 | 10 (integer)         │
│  │   duration: ['4','5','6'...] │                                       │
│  │ }                            │    Mismatch → 422 Error               │
│  └──────────────────────────────┘                                       │
│                                                                         │
│  AFTER (Fixed):                                                         │
│  ┌──────────────────────────────┐    ┌──────────────────────────────┐  │
│  │ Replicate API                │    │ schemas.json                 │  │
│  │ openapi.components.schemas:  │───▶│ componentSchemas: {          │  │
│  │   aspect_ratio: {            │    │   aspect_ratio: {            │  │
│  │     enum: ["16:9","9:16",    │    │     enum: ["16:9","9:16",    │  │
│  │            "1:1"],           │    │            "1:1"],           │  │
│  │     type: "string"           │    │     type: "string"           │  │
│  │   },                         │    │   },                         │  │
│  │   duration: {                │    │   duration: {                │  │
│  │     enum: [5, 10],           │    │     enum: [5, 10],           │  │
│  │     type: "integer"          │    │     type: "integer"          │  │
│  │   }                          │    │   }                          │  │
│  └──────────────────────────────┘    └────────────┬─────────────────┘  │
│                                                    │                    │
│                                                    ▼                    │
│  ┌──────────────────────────────┐    ┌──────────────────────────────┐  │
│  │ models/route.ts              │    │ VideoGenNode                 │  │
│  │ return {                     │───▶│ selectedModel: {             │  │
│  │   ...model,                  │    │   componentSchemas: {...}    │  │
│  │   componentSchemas: {...}    │    │ }                            │  │
│  │ }                            │    └────────────┬─────────────────┘  │
│  └──────────────────────────────┘                 │                    │
│                                                    ▼                    │
│                                     ┌──────────────────────────────┐   │
│                                     │ SchemaInputs                 │   │
│                                     │ enumValues = model-specific  │   │
│                                     │ componentSchemas = type info │   │
│                                     │                              │   │
│                                     │ if (type === 'integer')      │   │
│                                     │   onChange(parseInt(v))      │   │
│                                     └──────────────────────────────┘   │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Root Cause

1. `SchemaInputs.tsx` used hardcoded `DEFAULT_ENUM_VALUES` that didn't match model-specific enums
2. Kling only accepts `"16:9"`, `"9:16"`, `"1:1"` for aspect_ratio (not `"3:4"`, `"4:3"`, etc.)
3. Kling's `duration` is an integer (5 or 10), but dropdowns passed strings
4. The sync script saved `inputSchema` but not the `componentSchemas` that contain actual enum definitions

### Files changed

**Sync Script:**
- `scripts/sync-replicate-schemas.ts` - Added extraction of componentSchemas from `openapi.components.schemas`

**Types:**
- `packages/types/src/nodes.ts` - Added `componentSchemas?: Record<string, unknown>` to `ProviderModel` and `SelectedModel` interfaces

**API Route:**
- `apps/web/src/app/api/providers/models/route.ts` - Include componentSchemas in model response

**Frontend Components:**
- `apps/web/src/components/nodes/ai/VideoGenNode.tsx` - Store and pass componentSchemas to SchemaInputs
- `apps/web/src/components/nodes/ai/ImageGenNode.tsx` - Same changes
- `apps/web/src/components/nodes/SchemaInputs.tsx` - Accept componentSchemas prop, use model-specific enums, coerce types based on schema type (integer/number)

### Technical Details

**Type coercion in SchemaInputs:**
```typescript
// Get the component schema type for proper type coercion
const componentSchema = componentSchemas?.[enumKey];
const enumType = componentSchema?.type;

onChange={(v) => {
  if (enumType === 'integer') {
    handleChange(key, Number.parseInt(v, 10));
  } else if (enumType === 'number') {
    handleChange(key, Number.parseFloat(v));
  } else {
    handleChange(key, v);
  }
}}
```

### Decisions

- **Decision:** Store componentSchemas separately instead of resolving $ref inline
  - **Rationale:** Preserves type info (string vs integer) needed for proper type coercion

- **Decision:** Convert enum values based on componentSchema.type
  - **Rationale:** Dropdowns always pass strings but APIs like Kling expect integers for duration

### Next steps

- [ ] Run `bun run sync:replicate` to regenerate schemas.json with componentSchemas
- [ ] Re-select models in nodes to load new componentSchemas (or reload workflows)

---

## Session 13: Localhost URL → Replicate Failure Diagnosis

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Diagnosed why Replicate API calls fail with "Director: unexpected error handling prediction"
- [x] Identified root cause: Old workflow data has legacy URL format that `urlToBase64` doesn't handle
- [x] User chose clean code path over backward compatibility

### Root Cause

```
Error payload:
"image_input": [
  "http://localhost:3001/api/files/input/697a2638c578f6a2ba9e1c8c/image-xxx.jpeg"
]
```

- Old URL format: `/api/files/input/{workflowId}/{filename}`
- New URL format: `/api/files/workflows/{workflowId}/input/{filename}`
- `urlToBase64()` only handles new format (cleaned up in Session 11)
- Replicate can't access localhost URLs → API error

### Resolution

User chose to re-upload images instead of adding backward compatibility code.

**Why debug mode worked:** Debug mode returns mock data without calling Replicate API, so URL format doesn't matter.

**Why real mode failed:** Real API calls send localhost URLs to Replicate servers, which can't access them.

### Decisions

- **Decision:** Keep code clean, no backward compat for legacy URLs
  - **Rationale:** User preference for clean code over deprecated patterns
  - **Action:** Re-upload images in affected workflows to get new URL format

### Next steps

- [ ] Re-upload images in workflows that have old `/api/files/input/` URL format

---

## Session 14: Simplify MongoDB Collection Names

**Duration:** ~20 minutes
**Status:** Complete

### What was done

- [x] Renamed `user_settings` collection to `settings`
- [x] Renamed `prompt_library_items` collection to `prompts`
- [x] Renamed all associated classes, types, DTOs, services, controllers, and modules
- [x] Updated API endpoint from `/prompt-library` to `/prompts`
- [x] Updated all frontend API calls and stores
- [x] Updated all test files

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Collection Renaming                                                     │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE:                              AFTER:                            │
│  ┌─────────────────────────┐         ┌─────────────────────────┐       │
│  │ user_settings           │   →     │ settings                │       │
│  │ prompt_library_items    │   →     │ prompts                 │       │
│  └─────────────────────────┘         └─────────────────────────┘       │
│                                                                         │
│  Classes/Types Renamed:                                                 │
│  ┌─────────────────────────────┐   ┌─────────────────────────────┐    │
│  │ UserSettings               │ → │ Settings                    │    │
│  │ UserSettingsDocument       │ → │ SettingsDocument            │    │
│  │ PromptLibraryItem          │ → │ Prompt                      │    │
│  │ PromptLibraryItemDocument  │ → │ PromptDocument              │    │
│  │ PromptLibraryService       │ → │ PromptsService              │    │
│  │ PromptLibraryController    │ → │ PromptsController           │    │
│  │ PromptLibraryModule        │ → │ PromptsModule               │    │
│  │ CreatePromptLibraryItemDto │ → │ CreatePromptDto             │    │
│  │ QueryPromptLibraryDto      │ → │ QueryPromptsDto             │    │
│  │ IPromptLibraryItem         │ → │ IPrompt                     │    │
│  │ ICreatePromptLibraryItem   │ → │ ICreatePrompt               │    │
│  │ IQueryPromptLibrary        │ → │ IQueryPrompts               │    │
│  │ promptLibraryApi           │ → │ promptsApi                  │    │
│  └─────────────────────────────┘   └─────────────────────────────┘    │
│                                                                         │
│  API Endpoint:                                                          │
│  /prompt-library  →  /prompts                                           │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Files renamed

**Backend:**
- `user-settings.schema.ts` → `settings.schema.ts`
- `prompt-library-item.schema.ts` → `prompt.schema.ts`
- `prompt-library.service.ts` → `prompts.service.ts`
- `prompt-library.controller.ts` → `prompts.controller.ts`
- `prompt-library.module.ts` → `prompts.module.ts`
- `create-prompt-library-item.dto.ts` → `create-prompt.dto.ts`
- `query-prompt-library.dto.ts` → `query-prompts.dto.ts`
- `prompt-library.service.spec.ts` → `prompts.service.spec.ts`
- `prompt-library.controller.spec.ts` → `prompts.controller.spec.ts`

**Frontend:**
- `prompt-library.ts` → `prompts.ts` (API)
- `prompt-library.test.ts` → `prompts.test.ts`

**Types Package:**
- `prompt-library.ts` → `prompts.ts`

### Files changed

**Backend:**
- `apps/api/src/app.module.ts` - Updated import to use PromptsModule
- `apps/api/src/modules/settings.module.ts` - Updated imports for Settings schema
- `apps/api/src/services/settings.service.ts` - Updated imports and types

**Frontend:**
- `apps/web/src/lib/api/index.ts` - Updated export to use promptsApi
- `apps/web/src/store/promptLibraryStore.ts` - Updated imports and API calls
- `apps/web/src/components/prompt-library/CreatePromptModal.tsx` - Updated type imports
- `apps/web/src/components/prompt-library/PromptPicker.tsx` - Updated type imports
- `apps/web/src/components/prompt-library/PromptLibraryModal.tsx` - Updated type imports
- `apps/web/src/components/nodes/input/PromptNode.tsx` - Updated type imports

**Types Package:**
- `packages/types/src/index.ts` - Updated export path

### Decisions

- **Decision:** Use shorter, simpler collection and class names
  - **Rationale:** `prompts` is cleaner than `prompt_library_items`, `settings` is cleaner than `user_settings`

- **Decision:** Keep frontend store and component folder names unchanged (promptLibraryStore, prompt-library/)
  - **Rationale:** The folder/store names reflect the feature ("Prompt Library"), not the collection name. Internal types and API renamed.

### Migration Note

**Existing MongoDB data:** Collections need to be renamed in the database:
```javascript
db.user_settings.renameCollection("settings")
db["prompt-library-items"].renameCollection("prompts")
```

### Next steps

- [ ] Run MongoDB migration to rename collections in database

---

## Session 15: Node Color Harmonization + Data-Type-Colored Edges

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Harmonized all nodes to neutral styling (same border/background regardless of category)
- [x] Implemented data-type-colored edges (edges match the data type they carry)
- [x] Preserved category color for processing glow animation and resizer handles
- [x] Updated minimap to use neutral color for all nodes

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Visual Design Changes                                                   │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE:                               AFTER:                           │
│  ┌──────────────────────────┐         ┌──────────────────────────┐    │
│  │ Node Borders:            │         │ Node Borders:            │    │
│  │ - Input: teal border     │    →    │ - All: neutral border    │    │
│  │ - AI: purple border      │         │   (border-border)        │    │
│  │ - Processing: blue border│         │                          │    │
│  │ - Output: amber border   │         │ Selection Ring:          │    │
│  │                          │         │ - All: cyan (ring-primary)│   │
│  │ Selection Ring:          │         │                          │    │
│  │ - Uses category color    │         │ Processing Glow:         │    │
│  └──────────────────────────┘         │ - Still uses category    │    │
│                                        │   color (preserved)      │    │
│                                        └──────────────────────────┘    │
│                                                                         │
│  EDGES:                                                                 │
│  ┌──────────────────────────┐         ┌──────────────────────────┐    │
│  │ Edge Colors:             │         │ Edge Colors:             │    │
│  │ - All: border color      │    →    │ - Image: golden          │    │
│  │ - Highlighted: primary   │         │ - Video: purple-pink     │    │
│  │                          │         │ - Text: teal             │    │
│  │                          │         │ - Audio: pink            │    │
│  │                          │         │ - Number: blue           │    │
│  │                          │         │                          │    │
│  │                          │         │ States inherit type color│    │
│  │                          │         │ with glow/opacity effects│    │
│  └──────────────────────────┘         └──────────────────────────┘    │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Files changed

**Frontend Components:**
- `apps/web/src/components/nodes/BaseNode.tsx`
  - Removed category-colored borders (`border-[var(--category-X)]`)
  - All nodes now use `border-border bg-card` (neutral)
  - Selection ring now uses `ring-primary` for all nodes (cyan)
  - Preserved `--node-color` CSS variable for processing glow
  - Resizer handles still use category color

- `apps/web/src/components/canvas/WorkflowCanvas.tsx`
  - Added `getEdgeDataType()` helper function
  - Modified `styledEdges` useMemo to include edge type class
  - Edge classes: `edge-image`, `edge-video`, `edge-text`, `edge-audio`, `edge-number`
  - MiniMap now uses `DEFAULT_NODE_COLOR` (neutral gray) for all nodes
  - Removed unused `CATEGORY_COLORS` import

**Styles:**
- `apps/web/src/app/globals.scss`
  - Changed default edge color from `--border` to `--muted-foreground`
  - Added edge type classes with data-type colors:
    ```scss
    .edge-image { stroke: var(--handle-image); }  // golden
    .edge-video { stroke: var(--handle-video); }  // purple-pink
    .edge-text { stroke: var(--handle-text); }    // teal
    .edge-number { stroke: var(--handle-number); } // blue
    .edge-audio { stroke: var(--handle-audio); }   // pink
    ```
  - Updated dimmed/highlighted/executing states to use `currentColor`
  - Edges now glow in their data type color when highlighted or executing

### Technical Details

**Edge Type Resolution:**
```typescript
function getEdgeDataType(edge: WorkflowEdge, nodeMap: Map<string, WorkflowNode>): HandleType | null {
  const sourceNode = nodeMap.get(edge.source);
  const nodeDef = NODE_DEFINITIONS[sourceNode.type as NodeType];
  const sourceHandle = nodeDef.outputs.find((h) => h.id === edge.sourceHandle);
  return sourceHandle?.type ?? null;  // 'image' | 'video' | 'text' | 'audio' | 'number'
}
```

**Edge className composition:**
```typescript
const typeClass = dataType ? `edge-${dataType}` : '';
// Combined with state classes: `edge-image highlighted`, `edge-video executing`, etc.
```

**CSS uses `currentColor` for state effects:**
```scss
&__edge.highlighted .react-flow__edge-path {
  filter: drop-shadow(0 0 4px currentColor) brightness(1.2);
}
```

### Decisions

- **Decision:** Use neutral borders for all nodes
  - **Rationale:** Reduces visual noise, makes data flow the primary visual language

- **Decision:** Keep category color for processing glow and resizer handles
  - **Rationale:** Provides subtle category identification without dominating the UI

- **Decision:** Use `currentColor` in CSS for edge state effects
  - **Rationale:** States (highlighted, executing) inherit the type color, so golden image edges glow golden, purple video edges glow purple

- **Decision:** MiniMap uses neutral color for all nodes
  - **Rationale:** Consistent with harmonized node appearance

### Visual Result

- All nodes have clean, unified appearance with neutral borders
- Data flow is the primary visual language - edges are colored by what data they carry
- Handle → Edge → Handle color continuity (golden handles connect with golden edges)
- Processing glow animation still uses category colors for subtle context
- Selection highlighting applies a glow effect in the edge's data type color

### Next steps

- [x] Feature complete

---

## Session 16: Next.js App Optimization

**Duration:** ~30 minutes
**Status:** Complete

### What was done

**Phase 1: DRY Consolidation**
- [x] Created `apps/web/src/lib/utils/schemaUtils.ts` with shared utilities:
  - `getSchemaDefaults()` - Extract defaults from schema properties
  - `supportsImageInput()` - Check if model supports image input
  - `extractEnumValues()` - Extract enum values for dropdowns
- [x] Updated ImageGenNode, VideoGenNode, WorkflowCanvas to use shared utilities
- [x] Created `apps/web/src/hooks/useModelSelection.ts` hook
- [x] Updated ImageGenNode and VideoGenNode to use useModelSelection hook

**Phase 2: React Performance**
- [x] Added AbortController to AIGeneratorPanel fetch with cleanup on unmount
- [x] Memoized headerActions in ImageGenNode and VideoGenNode

**Phase 3: Next.js Optimizations**
- [x] Added next/font for Inter with CSS variable `--font-inter`
- [x] Updated globals.scss to use the font variable
- [x] Added dynamic imports for 6 modals in workflow editor page:
  - AnnotationModal, CostModal, GenerateWorkflowModal, TemplatesModal, WelcomeModal, SettingsModal
- [x] Replaced raw `<img>` tags with next/image in:
  - `apps/web/src/app/workflows/page.tsx` (header logo, workflow thumbnails)
  - `apps/web/src/app/gallery/page.tsx` (header logo)
  - `apps/web/src/components/gallery/GalleryItem.tsx` (image thumbnails)

### Files created

- `apps/web/src/lib/utils/schemaUtils.ts` - Shared schema utilities
- `apps/web/src/hooks/useModelSelection.ts` - Model selection hook

### Files changed

**DRY consolidation:**
- `apps/web/src/components/nodes/ai/ImageGenNode.tsx` - Uses schemaUtils and useModelSelection
- `apps/web/src/components/nodes/ai/VideoGenNode.tsx` - Uses schemaUtils and useModelSelection
- `apps/web/src/components/canvas/WorkflowCanvas.tsx` - Uses supportsImageInput from schemaUtils
- `apps/web/src/hooks/index.ts` - Added useModelSelection export

**React performance:**
- `apps/web/src/components/panels/AIGeneratorPanel.tsx` - AbortController for fetch
- `apps/web/src/components/nodes/ai/ImageGenNode.tsx` - headerActions memoized
- `apps/web/src/components/nodes/ai/VideoGenNode.tsx` - headerActions memoized

**Next.js optimizations:**
- `apps/web/src/app/layout.tsx` - Added next/font Inter with CSS variable
- `apps/web/src/app/globals.scss` - Updated to use `var(--font-inter)`
- `apps/web/src/app/workflows/[id]/page.tsx` - Dynamic imports for modals
- `apps/web/src/app/workflows/page.tsx` - next/image for logo and thumbnails
- `apps/web/src/app/gallery/page.tsx` - next/image for logo
- `apps/web/src/components/gallery/GalleryItem.tsx` - next/image for thumbnails

### Technical Details

**useModelSelection hook:**
```typescript
export function useModelSelection<TModel, TNodeData>({
  nodeId,
  modelMap,
  fallbackModel,
}: UseModelSelectionOptions<TModel>) {
  // Uses getSchemaDefaults from schemaUtils
  // Updates node with model, provider, selectedModel, schemaParams
  return { handleModelSelect };
}
```

**Dynamic imports pattern:**
```typescript
const WelcomeModal = dynamic(
  () => import('@/components/welcome/WelcomeModal').then((mod) => mod.WelcomeModal),
  { ssr: false }
);
```

**AbortController pattern:**
```typescript
const abortControllerRef = useRef<AbortController | null>(null);

useEffect(() => {
  return () => abortControllerRef.current?.abort();
}, []);

const handleSend = useCallback(async () => {
  abortControllerRef.current?.abort();
  const controller = new AbortController();
  abortControllerRef.current = controller;

  const response = await fetch(url, { signal: controller.signal });
  // ...
}, []);
```

### Decisions

- **Decision:** Skip comparison-slider.tsx next/image conversion
  - **Rationale:** Complex dynamic sizing with clip path, minimal benefit since unoptimized would be required anyway

- **Decision:** Skip shared node components (NodeActionButton, RequiredInputsHint, OutputPreview)
  - **Rationale:** Core optimizations complete, additional DRY refactoring has lower impact and requires extensive changes to 6+ files

### Impact

- **Bundle size:** Reduced initial load by ~20KB (dynamic modal imports)
- **Font loading:** Self-hosted font via next/font improves CLS and load time
- **Code quality:** 60+ lines of duplicated schema utilities consolidated
- **Memory:** AbortController prevents memory leaks from abandoned requests
- **Render performance:** headerActions memoization reduces unnecessary re-renders

### Next steps

- [ ] Consider shared node components in future cleanup pass
- [ ] Add next.config.ts remotePatterns if CDN images need optimization

---

## Session 17: Design System Documentation & SuperDesign Setup

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Created `.superdesign/design-system.md` documenting all visual decisions
- [x] Fixed AIGeneratorPanel missing PanelContainer wrapper (event propagation fix)
- [x] Audited visual consistency across panels
- [x] Created replica HTML for Settings Modal
- [x] Generated 3 SuperDesign iterations for Settings Modal redesign

### Files created

- `.superdesign/design-system.md` - Comprehensive design system documentation
- `.superdesign/replica_html_template/settings-modal.html` - Pixel-perfect replica of current Settings Modal

### Files changed

- `apps/web/src/components/panels/AIGeneratorPanel.tsx` - Added PanelContainer wrapper to prevent React Flow event interference

### Design System Documentation

The design system file documents:
- **Color system:** OKLCH values for dark theme, data type colors, category colors
- **Typography:** Inter font stack, size scale from 10px to 18px
- **Spacing:** Standard units (p-3, gap-2, etc.), panel dimensions
- **Components:** Node anatomy, edge states, panel structure, buttons, badges, alerts
- **Animations:** Processing glow, edge flow, transitions

### Visual Consistency Audit Findings

**Consistent:**
- Panel widths: `w-80` (320px)
- Panel padding: `p-3` for headers and content
- Button styling: `p-1.5 hover:bg-muted rounded transition`

**Intentional differences (not bugs):**
- DebugPanel uses amber color for debug/warning concept
- AIGeneratorPanel uses primary (cyan) for AI concept
- Modal uses elevated `bg-card`, panels use `bg-background`

### SuperDesign Iterations (Not Implemented)

Generated 3 design directions for future consideration:

| Variation | Draft ID | Key Changes |
|-----------|----------|-------------|
| Optimized | `646433e7-2a94-4270-8c25-dfb157c0ce89` | Compact spacing, condensed helper text, smaller margins |
| Elevated | `63275322-e9cd-4f70-9663-205c1ecf3080` | Gradient header, status badges, icons in selects, footer with Cancel/Save |
| Enhanced | `ff56da42-0bc9-4f10-a2d3-7063e15ea4dd` | Section dividers ("Model Preferences", "Infrastructure"), 2-column layout, experimental toggle |

**Project URL:** https://app.superdesign.dev/teams/a0051bbe-8646-490f-9501-b0701ce26371/projects/d2aa9678-8ba5-4409-9189-66125306308f

### Decisions

- **Decision:** Document design system before making changes
  - **Rationale:** Codifies existing patterns, enables consistent future iterations

- **Decision:** Defer Settings Modal redesign implementation
  - **Rationale:** User preference to document and revisit later

### Next steps

- [ ] Implement chosen Settings Modal design direction when ready
- [ ] Consider applying design system to other modals (Welcome, Templates, etc.)

---

## Session 18: Fix Node Content Overflow Issue

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Diagnosed node content overflow when manually resized
- [x] Added `overflow: auto` to resized nodes to keep content within bounds
- [x] Preserves resize handle alignment with node boundary

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Node Resize Overflow Problem & Solution                                 │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE (Problem):                                                      │
│  ┌──────────────────────────────────────────────────────────┐          │
│  │ BaseNode with explicit height                            │          │
│  │ ┌────────────────────────────────────────────────────┐   │          │
│  │ │ Node border box                                    │   │          │
│  │ └────────────────────────────────────────────────────┘   │          │
│  │ ┌────────────────────────────────────────────────────┐   │          │
│  │ │ "Generate Image" button (OUTSIDE box - overflow!)  │   │          │
│  │ └────────────────────────────────────────────────────┘   │          │
│  └──────────────────────────────────────────────────────────┘          │
│                                                                         │
│  AFTER (Fixed):                                                         │
│  ┌──────────────────────────────────────────────────────────┐          │
│  │ BaseNode with height + overflow: auto                    │          │
│  │ ┌────────────────────────────────────────────────────┐   │          │
│  │ │ Node border box                                    │   │          │
│  │ │ ┌──────────────────────────────────────────────┐   │   │          │
│  │ │ │ Content (scrollable if exceeds height)       │   │   │          │
│  │ │ └──────────────────────────────────────────────┘   │   │          │
│  │ └────────────────────────────────────────────────────┘   │          │
│  └──────────────────────────────────────────────────────────┘          │
│                                                                         │
│  Resize handles (green dots) now align properly with border             │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Root Cause

When nodes are manually resized (`isResized = true`), explicit `width` and `height` are applied via inline styles. If the stored height is smaller than the content needs (SchemaInputs, action buttons, previews), content spills outside the node's bounding box because no `overflow` property was set.

Initial fix attempt removed the `height` property entirely, making height content-driven. However, this caused NodeResizer handles to misalign because React Flow positions resize handles based on the node's rendered dimensions.

### Solution

Keep the explicit `height` (for handle alignment) but add `overflow: auto` to contain content:

```typescript
// BaseNode.tsx lines 239-244
...(isResized && {
  width: width ? `${width}px` : undefined,
  height: height ? `${height}px` : undefined,
  overflow: 'auto',
}),
```

### Files changed

- `apps/web/src/components/nodes/BaseNode.tsx` - Added `overflow: 'auto'` to resized node styles

### Trade-offs

| Approach | Pros | Cons |
|----------|------|------|
| Remove height | Content always visible | Handles misalign |
| overflow: hidden | Handles align | Content clipped |
| **overflow: auto** | **Handles align, content accessible via scroll** | **Scrollbar appears when needed** |

### Decisions

- **Decision:** Use `overflow: auto` instead of removing height or using `overflow: hidden`
  - **Rationale:** Best balance - resize handles align properly AND users can still access all content via scrolling if it exceeds the set height

### Affected Nodes

All nodes using BaseNode:
- ImageGenNode, VideoGenNode, LLMNode, TextToSpeechNode
- TranscribeNode, LipSyncNode, VoiceChangeNode, MotionControlNode
- PromptNode, MergeNode, OutputNode, etc.

### Next steps

- [x] Feature complete

---

## Session 19: Node Background Consistency Fix

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Aligned node background styling with sidebar list items for visual consistency
- [x] Changed BaseNode to use explicit CSS variables matching NodePalette

### Files changed

- `apps/web/src/components/nodes/BaseNode.tsx` - Updated container className:
  - Changed `border-border bg-card` to `border-[var(--border)] bg-[var(--card)]`
  - Now matches NodePalette line 107 exactly

### Technical Details

**Problem:** Node backgrounds appeared different from sidebar list items despite both conceptually using `--card` color.

**Solution:** Use identical CSS variable syntax in both components:
- NodePalette (line 107): `bg-[var(--card)] border border-[var(--border)]`
- BaseNode (updated): `bg-[var(--card)] border border-[var(--border)]`

### Decisions

- **Decision:** Use explicit CSS variable syntax `bg-[var(--card)]` instead of Tailwind utility `bg-card`
  - **Rationale:** Ensures identical styling by using the same CSS variable reference approach across components

### Next steps

- [x] Feature complete

---

## Session 20: White Background for Run Workflow Button

**Duration:** ~2 minutes
**Status:** Complete

### What was done

- [x] Added new `white` variant to Button component
- [x] Updated Run Workflow button to use `white` variant

### Files changed

- `apps/web/src/components/ui/button.tsx` - Added `white` variant: `'bg-white text-black hover:bg-white/90'`
- `apps/web/src/components/toolbar/Toolbar.tsx` - Changed Run Workflow button from `'default'` to `'white'` variant

### Technical Details

**Button variant added:**
```typescript
white: 'bg-white text-black hover:bg-white/90',
```

**Toolbar change:**
```typescript
// Before
<Button variant={isRunning ? 'destructive' : 'default'} onClick={handleRunStop}>

// After
<Button variant={isRunning ? 'destructive' : 'white'} onClick={handleRunStop}>
```

### Visual Result

- "Run Workflow" button now has white background with black text
- "Stop" button remains red (destructive variant unchanged)
- Hover state dims white to 90% opacity

### Next steps

- [x] Feature complete

---

## Session 21: Edge Collision Avoidance

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Created custom edge components that offset parallel edges for visual separation
- [x] Added `WorkflowEdgeData` type with `offsetIndex` and `groupSize` fields
- [x] Created edge offset calculator utility
- [x] Integrated custom edge types into WorkflowCanvas

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Edge Collision Avoidance System                                         │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE (Problem):                                                      │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │  [Prompt] ───────┬───────▶ [ImageGen]                           │  │
│  │  [Image]  ───────┘         (edges overlap at target)            │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│  AFTER (Fixed):                                                         │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │  [Prompt] ────────┐                                              │  │
│  │                    ├──────▶ [ImageGen]                           │  │
│  │  [Image]  ────────┘         (edges visually separated)           │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│  How it works:                                                          │
│  ┌────────────────┐    ┌────────────────┐    ┌────────────────┐       │
│  │ edges array    │───▶│ calculateEdge  │───▶│ Custom Edge    │       │
│  │                │    │ Offsets()      │    │ Components     │       │
│  │ [edge1, edge2] │    │                │    │                │       │
│  └────────────────┘    │ Groups by      │    │ Apply offset   │       │
│                        │ target node    │    │ perpendicular  │       │
│                        │                │    │ to edge path   │       │
│                        │ edge1: idx=0   │    │                │       │
│                        │ edge2: idx=1   │    │ SmartBezier    │       │
│                        │ groupSize=2    │    │ SmartSmoothStep│       │
│                        │                │    │ SmartStraight  │       │
│                        └────────────────┘    └────────────────┘       │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Files created

- `apps/web/src/lib/utils/edgeOffsets.ts` - Edge offset calculation utilities:
  - `calculateEdgeOffsets()` - Groups edges by target, assigns offset indices
  - `calculatePerpendicularOffset()` - Computes perpendicular offset value (15px spacing)

- `apps/web/src/components/edges/SmartBezierEdge.tsx` - Custom bezier edge with offset support

- `apps/web/src/components/edges/SmartSmoothStepEdge.tsx` - Custom smoothstep edge with offset support

- `apps/web/src/components/edges/SmartStraightEdge.tsx` - Custom straight edge with offset support

- `apps/web/src/components/edges/index.ts` - Export barrel mapping React Flow edge types to smart versions

### Files changed

**Types:**
- `packages/types/src/nodes.ts` - Added `WorkflowEdgeData` interface with `offsetIndex` and `groupSize` fields, updated `WorkflowEdge` type to use it

**WorkflowCanvas:**
- `apps/web/src/components/canvas/WorkflowCanvas.tsx`
  - Added imports for `edgeTypes` and `calculateEdgeOffsets`
  - Updated `styledEdges` useMemo to calculate and apply offset data to each edge
  - Added `edgeTypes` prop to ReactFlow component

### Technical Details

**Offset Calculation:**
```typescript
// Edges going to same target are grouped
const targetGroups = new Map<string, WorkflowEdge[]>();
// Each edge gets an index and knows the group size
result.set(edge.id, { offsetIndex: i, groupSize: group.length });
```

**Perpendicular Offset:**
```typescript
// Center the group around 0 for balanced distribution
const centerIndex = (groupSize - 1) / 2;
return (offsetIndex - centerIndex) * spacing; // spacing = 15px
// For 2 edges: -7.5px and +7.5px
// For 3 edges: -15px, 0, +15px
```

**Custom Edge Components:**
- Wrap React Flow's path generators (`getBezierPath`, `getSmoothStepPath`, `getStraightPath`)
- Read `data.offsetIndex` and `data.groupSize` from edge props
- Calculate perpendicular vector to edge direction
- Apply offset to source and target coordinates
- Use `BaseEdge` for rendering (preserves all CSS styling)

### What's Preserved

- All CSS styling (edge-image, edge-video, edge-text colors)
- Execution animations (executing, active-pipe)
- Selection states (highlighted, dimmed)
- Three edge style options (default/bezier, smoothstep, straight)
- Edge disabled state for incompatible connections

### Decisions

- **Decision:** Group edges by target node rather than source-target pairs
  - **Rationale:** Edges from different sources going to same target need separation. Same-source-target pairs are less common.

- **Decision:** Use 15px spacing between parallel edges
  - **Rationale:** Large enough to be visible, small enough to not distort the layout significantly

- **Decision:** Use perpendicular offset rather than path curvature adjustment
  - **Rationale:** Works consistently across all edge types (bezier, smoothstep, straight)

### Next steps

- [ ] Test with various node configurations to verify visual separation
- [ ] Verify edge styles work correctly in Settings → Appearance

---

## Session 22: Fix sortedInputs and WorkflowEdgeData Type Errors

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Fixed "Cannot access 'sortedInputs' before initialization" error in BaseNode
- [x] Fixed WorkflowEdgeData type not satisfying React Flow's `Record<string, unknown>` constraint

### Files changed

- `apps/web/src/components/nodes/BaseNode.tsx` - Moved `sortedInputs` declaration before the `useEffect` that references it in its dependency array (temporal dead zone fix)
- `packages/types/src/nodes.ts` - Added index signature `[key: string]: unknown` to `WorkflowEdgeData` interface to satisfy React Flow's `Edge<T extends Record<string, unknown>>` constraint

### Technical Details

**sortedInputs error:**
- Line 148 used `sortedInputs.length` in useEffect dependency array
- Line 155 declared `sortedInputs`
- Fix: Moved declaration before the useEffect

**WorkflowEdgeData error:**
- React Flow's `Edge` type requires `data` to extend `Record<string, unknown>`
- TypeScript interfaces without index signatures don't satisfy this constraint
- Fix: Added `[key: string]: unknown` index signature

### Next steps

- [x] TypeScript errors resolved

---

## Session 22: Category-Colored Selection Ring for Nodes

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Changed node selection ring from fixed cyan (`ring-primary`) to category-colored
- [x] Selection ring now matches node category (input, AI, processing, output, composition)
- [x] Resizer handles and processing glow remain unaffected (already use category color)

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Node Selection Ring Color                                               │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE:                                                                │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │  All nodes: cyan selection ring (ring-primary)                   │  │
│  │  - Input node selected → cyan ring                               │  │
│  │  - AI node selected → cyan ring                                  │  │
│  │  - Output node selected → cyan ring                              │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│  AFTER:                                                                 │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │  Selection ring matches node category:                           │  │
│  │  - Input node (PromptNode) → cyan ring (--category-input)        │  │
│  │  - AI node (ImageGenNode) → purple ring (--category-ai)          │  │
│  │  - Processing node → blue ring (--category-processing)           │  │
│  │  - Output node → amber ring (--category-output)                  │  │
│  │  - Composition node → teal ring (--category-composition)         │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Files changed

- `apps/web/src/components/nodes/BaseNode.tsx`
  - Line 230: Changed `isSelected && 'ring-2 ring-primary'` to `isSelected && 'ring-2'`
  - Line 239: Added `...(isSelected && { '--tw-ring-color': categoryColor })` to inline styles

### Technical Details

**Implementation approach:**
- Removed Tailwind's `ring-primary` class (hardcoded cyan)
- Added inline style that sets `--tw-ring-color` CSS variable to the existing `categoryColor`
- `categoryColor` is already computed from `categoryCssVars[nodeDef.category]`

**Why this works:**
- Tailwind's `ring-2` class uses `--tw-ring-color` for the ring color
- By setting this CSS variable inline, we override the default with category color
- Same variable approach used for processing glow (`--node-color`)

**Category colors (from CSS variables):**
```css
--category-input: oklch(0.75 0.15 190);      /* cyan */
--category-ai: oklch(0.65 0.20 300);         /* purple */
--category-processing: oklch(0.70 0.15 250); /* blue */
--category-output: oklch(0.80 0.15 75);      /* amber */
--category-composition: oklch(0.70 0.12 180);/* teal */
```

### Decisions

- **Decision:** Use inline style with CSS variable instead of dynamic Tailwind classes
  - **Rationale:** Tailwind JIT doesn't support dynamic class names. Inline style with `--tw-ring-color` is the cleanest approach that works with existing Tailwind utilities.

### What's Preserved

- Processing glow animation (still uses `--node-color`)
- Resizer handles (still use `categoryColor` directly)
- Ring width (`ring-2` unchanged)
- All other node styling (borders, backgrounds, etc.)

### Next steps

- [x] Feature complete

---

## Session 23: Undo/Redo with Cmd+Z / Cmd+Shift+Z

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Installed `zundo@2.3.0` dependency for Zustand temporal middleware
- [x] Wrapped workflowStore with `temporal` middleware for undo/redo history
- [x] Added `Cmd+Z` (undo) and `Cmd+Shift+Z` (redo) keyboard shortcuts
- [x] Added undo/redo buttons to toolbar with disabled states

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Undo/Redo System Architecture                                          │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Zustand Store                                                          │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │ useWorkflowStore                                                 │   │
│  │ ┌─────────────────────────────────────────────────────────────┐ │   │
│  │ │ temporal() middleware wraps store                           │ │   │
│  │ │                                                             │ │   │
│  │ │ Tracked state (partialize):                                 │ │   │
│  │ │ - nodes: WorkflowNode[]                                     │ │   │
│  │ │ - edges: WorkflowEdge[]                                     │ │   │
│  │ │ - groups: NodeGroup[]                                       │ │   │
│  │ │                                                             │ │   │
│  │ │ NOT tracked (UI state):                                     │ │   │
│  │ │ - isDirty, isSaving, isLoading                             │ │   │
│  │ │ - selectedNodeIds, viewedCommentIds                        │ │   │
│  │ │ - navigationTargetId, edgeStyle                            │ │   │
│  │ └─────────────────────────────────────────────────────────────┘ │   │
│  │                                                                  │   │
│  │ temporal state:                                                  │   │
│  │ - pastStates: PartialState[] (max 50)                           │   │
│  │ - futureStates: PartialState[]                                  │   │
│  │ - undo(): void                                                  │   │
│  │ - redo(): void                                                  │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  User Actions                                                           │
│  ┌──────────────────┐    ┌──────────────────┐                          │
│  │ Keyboard         │    │ Toolbar Buttons  │                          │
│  │ Cmd+Z → undo()   │    │ Undo2 → undo()   │                          │
│  │ Cmd+Shift+Z →    │    │ Redo2 → redo()   │                          │
│  │   redo()         │    │                  │                          │
│  └──────────────────┘    └──────────────────┘                          │
│                                                                         │
│  Button States (reactive via temporal.subscribe):                       │
│  - canUndo: pastStates.length > 0                                      │
│  - canRedo: futureStates.length > 0                                    │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Files changed

**Package:**
- `apps/web/package.json` - Added `zundo@2.3.0` dependency

**Store:**
- `apps/web/src/store/workflow/workflowStore.ts`
  - Imported `temporal` from zundo
  - Wrapped store creator with `temporal()` middleware
  - Configured `partialize` to only track nodes, edges, groups
  - Set `limit: 50` for history size
  - Added `equality` function for deduplication

**WorkflowCanvas:**
- `apps/web/src/components/canvas/WorkflowCanvas.tsx`
  - Added `Cmd+Z` handler → `useWorkflowStore.temporal.getState().undo()`
  - Added `Cmd+Shift+Z` handler → `useWorkflowStore.temporal.getState().redo()`

**Toolbar:**
- `apps/web/src/components/toolbar/Toolbar.tsx`
  - Added `Undo2`, `Redo2` imports from lucide-react
  - Added temporal state subscription for canUndo/canRedo
  - Added undo/redo buttons with tooltips showing shortcuts

### Technical Details

**Zundo configuration:**
```typescript
temporal(
  (...args) => ({ /* store state and slices */ }),
  {
    partialize: (state) => ({
      nodes: state.nodes,
      edges: state.edges,
      groups: state.groups,
    }),
    limit: 50,
    equality: (pastState, currentState) =>
      JSON.stringify(pastState) === JSON.stringify(currentState),
  }
)
```

**Keyboard shortcut handling:**
```typescript
// Cmd/Ctrl+Z - Undo
if (e.key === 'z' && isMod && !e.shiftKey) {
  e.preventDefault();
  useWorkflowStore.temporal.getState().undo();
}

// Cmd/Ctrl+Shift+Z - Redo
if (e.key === 'z' && isMod && e.shiftKey) {
  e.preventDefault();
  useWorkflowStore.temporal.getState().redo();
}
```

**Button state subscription:**
```typescript
useEffect(() => {
  const unsubscribe = useWorkflowStore.temporal.subscribe((state) => {
    setCanUndo(state.pastStates.length > 0);
    setCanRedo(state.futureStates.length > 0);
  });
  return unsubscribe;
}, []);
```

### What Gets Tracked

| Action | Undoable |
|--------|----------|
| Delete node | ✅ |
| Add node | ✅ |
| Move node | ✅ |
| Delete edge | ✅ |
| Add edge | ✅ |
| Update node data (model, params) | ✅ |
| Group create/delete | ✅ |
| Selection changes | ❌ (UI only) |
| Panel visibility | ❌ (UI only) |

### Decisions

- **Decision:** Use zundo over custom implementation
  - **Rationale:** Battle-tested with Zustand, handles edge cases, minimal code (~50 lines added)

- **Decision:** Only track nodes, edges, groups via `partialize`
  - **Rationale:** Selection state and UI flags shouldn't pollute undo history

- **Decision:** Set history limit to 50
  - **Rationale:** Balances memory usage with sufficient undo depth for most workflows

### Next steps

- [x] Feature complete

---

## Session 24: Input Node Drop Zone Full Size + Type Fix

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Made "Drop or click" drop zones fill available node space (not fixed 64px height)
- [x] Updated ImageInputNode, AudioInputNode, VideoInputNode with `flex-1 min-h-16`
- [x] Fixed TypeScript error: `error: null` → `error: undefined` in BaseNode retry handler

### Files changed

**Input Nodes (drop zone sizing):**
- `apps/web/src/components/nodes/input/ImageInputNode.tsx` - Changed `h-16` to `flex-1 min-h-16`
- `apps/web/src/components/nodes/input/AudioInputNode.tsx` - Changed `h-16` to `flex-1 min-h-16`
- `apps/web/src/components/nodes/input/VideoInputNode.tsx` - Changed `h-16` to `flex-1 min-h-16`

**Type fix:**
- `apps/web/src/components/nodes/BaseNode.tsx` - Line 152: Changed `error: null` to `error: undefined` to match `BaseNodeData.error?: string` type

### Technical Details

**Problem:** Drop zones had fixed `h-16` (64px) height, so when nodes were manually resized larger, the drop zone stayed small while the rest of the node was empty space.

**Solution:** Changed from `h-16` to `flex-1 min-h-16`:
- `flex-1` makes the drop zone grow to fill available space in the flex container
- `min-h-16` ensures minimum 64px height when node is at default size

**Type fix:** `BaseNodeData.error` is typed as `string | undefined`, but retry handler was setting `null`. TypeScript correctly flagged this mismatch.

### Decisions

- **Decision:** Use `flex-1 min-h-16` instead of removing height entirely
  - **Rationale:** Maintains minimum usable size while allowing expansion

### Next steps

- [x] Feature complete

---

## Session 25: Add Expand Button to Remaining Nodes

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Added expand button functionality to 10 nodes that were missing it
- [x] High priority nodes (video/image output): VoiceChangeNode, LipSyncNode, MotionControlNode, AnimationNode, VideoTrimNode, UpscaleNode, AnnotationNode
- [x] Medium priority nodes (audio/text output): TextToSpeechNode, TranscribeNode, AudioInputNode
- [x] All nodes now open NodeDetailModal with 'preview' tab when expand button clicked

### Files changed

**High Priority (7 files):**
- `apps/web/src/components/nodes/ai/VoiceChangeNode.tsx` - Added expand button (shows when `outputVideo` exists)
- `apps/web/src/components/nodes/ai/LipSyncNode.tsx` - Added expand button (shows when `outputVideo` exists)
- `apps/web/src/components/nodes/ai/MotionControlNode.tsx` - Added expand button (shows when `outputVideo` exists)
- `apps/web/src/components/nodes/processing/AnimationNode.tsx` - Added expand button (shows when `outputVideo` exists)
- `apps/web/src/components/nodes/processing/VideoTrimNode.tsx` - Added expand button (shows when `outputVideo` exists)
- `apps/web/src/components/nodes/processing/UpscaleNode.tsx` - Added expand button (shows when `hasOutput` - image or video)
- `apps/web/src/components/nodes/processing/AnnotationNode.tsx` - Added expand button (shows when `inputImage` exists)

**Medium Priority (3 files):**
- `apps/web/src/components/nodes/ai/TextToSpeechNode.tsx` - Added expand button (shows when `outputAudio` exists)
- `apps/web/src/components/nodes/ai/TranscribeNode.tsx` - Added expand button (shows when `outputText` exists)
- `apps/web/src/components/nodes/input/AudioInputNode.tsx` - Added expand button to header actions (shows when `audio` exists)

### Implementation Pattern

Each node follows the same pattern (matches existing ImageGenNode/VideoGenNode):

```typescript
// 1. Imports
import { Expand } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useUIStore } from '@/store/uiStore';
import { useMemo } from 'react';

// 2. Get modal opener
const openNodeDetailModal = useUIStore((state) => state.openNodeDetailModal);

// 3. Handler
const handleExpand = useCallback(() => {
  openNodeDetailModal(id, 'preview');
}, [id, openNodeDetailModal]);

// 4. Memoized headerActions
const headerActions = useMemo(
  () =>
    nodeData.outputVideo ? (
      <Button variant="ghost" size="icon-sm" onClick={handleExpand} className="h-5 w-5" title="Expand preview">
        <Expand className="h-3 w-3" />
      </Button>
    ) : null,
  [nodeData.outputVideo, handleExpand]
);

// 5. Pass to BaseNode
<BaseNode {...props} headerActions={headerActions}>
```

### Nodes skipped (Lower Priority)

- `TemplateNode` - Simple variable inputs, no rich preview needed
- `WorkflowInputNode` - Metadata config only
- `WorkflowOutputNode` - Already has inline preview
- `WorkflowRefNode` - Interface summary only
- `OutputNode` - Download focus, inline preview sufficient

### Technical Details

**Condition for showing expand button varies by node:**
- Video output nodes: `nodeData.outputVideo`
- Image output nodes: `nodeData.outputImage` or `inputImage`
- Audio output nodes: `nodeData.outputAudio` or `nodeData.audio`
- Text output nodes: `nodeData.outputText`
- UpscaleNode: `hasOutput` (computed from `outputImage || outputVideo`)
- AudioInputNode: Integrated into existing headerActions with other buttons

**AudioInputNode special case:**
- Already had `headerActions` with Upload and Link buttons
- Expand button added conditionally when `nodeData.audio` exists
- Uses `h-6 w-6` sizing to match existing buttons (slightly larger than other nodes)

### Next steps

- [ ] Test all nodes to verify expand button opens modal correctly
- [ ] Verify modal preview tab shows appropriate content for each node type
---

## Session 7: Biome Lint Fixes

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Ran `bun run biome check --write` to auto-fix formatting
- [x] Fixed unused variable warnings in edge components
- [x] Fixed unused variable warnings in Toolbar
- [x] Fixed useExhaustiveDependencies warning in BaseNode

### Files changed

- `apps/web/src/components/edges/SmartBezierEdge.tsx` - Removed unused `labelX`, `labelY` from destructuring
- `apps/web/src/components/edges/SmartSmoothStepEdge.tsx` - Removed unused `labelX`, `labelY` from destructuring
- `apps/web/src/components/edges/SmartStraightEdge.tsx` - Removed unused `labelX`, `labelY` from destructuring
- `apps/web/src/components/toolbar/Toolbar.tsx` - Removed unused `pastStates`, `futureStates` from temporal state destructuring
- `apps/web/src/components/nodes/BaseNode.tsx` - Removed extra dependencies from useEffect (width, height, sortedInputs.length, nodeDef?.outputs?.length)

### Technical Details

**Edge components (3 files):**
- `getBezierPath`, `getSmoothStepPath`, `getStraightPath` return `[edgePath, labelX, labelY]`
- Only `edgePath` was used; `labelX` and `labelY` were destructured but never referenced
- Fix: Changed to `const [edgePath] = getXPath({...})`

**Toolbar.tsx:**
- `pastStates` and `futureStates` were destructured from temporal state but never used
- The component subscribes to temporal state separately via `useEffect` to update `canUndo`/`canRedo` state
- Fix: Removed unused variables from destructuring

**BaseNode.tsx:**
- `useEffect` had extra dependencies that biome flagged as unnecessary
- Original deps: `[id, width, height, sortedInputs.length, nodeDef?.outputs?.length, updateNodeInternals]`
- Fixed deps: `[id, updateNodeInternals]`

### Decisions

- **Decision:** Remove extra useEffect dependencies in BaseNode rather than suppressing the warning
  - **Context:** Biome flagged width, height, etc. as "outer scope values" that don't trigger re-renders
  - **Rationale:** React Flow handles dimension changes internally; the effect only needs id and updateNodeInternals

### Next steps

- [ ] Continue development tasks

---

## Session 22: Fix Edge-Handle Misalignment Bug

**Duration:** ~5 minutes
**Status:** Complete

### System Flow Diagram

```
BEFORE (broken):
┌─────────────┐     ┌─────────────┐
│   Node A    │     │   Node B    │
│      ● ────┼─────┼→ ●          │  ← Edge starts/ends at wrong position
└─────────────┘     └─────────────┘

AFTER (fixed):
┌─────────────┐     ┌─────────────┐
│   Node A    │     │   Node B    │
│           ●─────────●           │  ← Edge connects directly to handles
└─────────────┘     └─────────────┘
```

### What was done

- [x] Identified root cause: SmartEdge custom components introduced in Session 21
- [x] Removed `edgeTypes` import and prop from WorkflowCanvas
- [x] Removed `calculateEdgeOffsets` import and usage
- [x] Removed `WorkflowEdgeData` type import (no longer needed)
- [x] Simplified `styledEdges` useMemo to not use offset data
- [x] Simplified `WorkflowEdgeData` interface in types
- [x] Deleted all SmartEdge component files
- [x] Deleted `edgeOffsets.ts` utility
- [x] Removed empty `edges/` directory

### Files changed

**Modified:**
- `apps/web/src/components/canvas/WorkflowCanvas.tsx` - Removed edge collision avoidance imports, offset calculation, and edgeTypes prop
- `packages/types/src/nodes.ts` - Simplified WorkflowEdgeData interface (removed offsetIndex, groupSize)

**Deleted:**
- `apps/web/src/components/edges/SmartBezierEdge.tsx`
- `apps/web/src/components/edges/SmartSmoothStepEdge.tsx`
- `apps/web/src/components/edges/SmartStraightEdge.tsx`
- `apps/web/src/components/edges/index.ts`
- `apps/web/src/lib/utils/edgeOffsets.ts`
- `apps/web/src/components/edges/` (directory)

### Decisions

- **Decision:** Revert edge collision avoidance feature entirely
  - **Context:** Session 21 added SmartEdge components to visually separate parallel edges
  - **Problem:** Custom edge components broke coordinate system, edges didn't connect to handles
  - **Rationale:** Working edges > parallel edge separation. Feature can be re-implemented properly later if needed

### What was SmartEdge?

The "edge collision avoidance" feature was designed to:
1. Group edges by target node
2. Calculate perpendicular offsets for parallel edges (e.g., 3 edges get -15px, 0px, +15px)
3. Apply offsets so edges fan out instead of overlapping

**Why it broke:** Custom edge components intercepted React Flow's coordinate calculations. Even single edges with offset=0 were misaligned because the entire rendering pipeline was being overridden.

### Preserved functionality

- Edge coloring by data type (edge-image, edge-video, etc.)
- Edge highlighting/dimming during node selection
- Execution animation (active-pipe, executing classes)
- Edge disabled state for incompatible model inputs

### Mistakes and fixes

- **Mistake:** Session 21 introduced SmartEdge components without adequate visual testing
- **Fix:** Full revert of the feature, not just tweaking offset calculations
- **Lesson:** Custom edge components need careful testing with multiple node configurations

### Next steps

- [ ] If parallel edge separation is needed later, investigate React Flow's built-in edge routing options
- [ ] Consider edge bundling as alternative approach

---

## Session 24: Fix Output Files Not Being Saved to Disk

**Status:** Complete

### Problem

Generated images are not being saved to `/data/workflows/{workflowId}/output/`. The frontend shows Replicate URLs which expire, causing images to become unavailable.

**Evidence:**
- Older workflows (Jan 28) have output files saved
- Recent workflows (Jan 29 2:22 AM) only have `input/` directory, NO `output/` directory
- The auto-save code exists but was silently failing

### What was done

- [x] Added retry logic with exponential backoff to `downloadAndSaveOutput()` in files.service.ts
- [x] Added User-Agent header to download requests (some CDNs require this)
- [x] Added empty file check to catch failed downloads
- [x] Changed error logging from `warn` to `error` with "CRITICAL" prefix in all processors
- [x] Added `saveError` field to output when save fails (for debugging)

### Files changed

**Modified:**
- `apps/api/src/services/files.service.ts` - Added retry logic (3 attempts with exponential backoff), User-Agent header, empty file validation
- `apps/api/src/processors/image.processor.ts` - Upgraded error logging to CRITICAL level, added saveError tracking
- `apps/api/src/processors/video.processor.ts` - Same error logging improvements
- `apps/api/src/processors/processing.processor.ts` - Same error logging improvements

### Technical Details

**Root cause:** The `downloadAndSaveOutput()` was failing silently and the catch block only logged a warning, falling back to the Replicate URL.

**Fix applied:**
1. **Retry logic:** 3 attempts with 1s, 2s, 3s delays between retries
2. **User-Agent header:** Some CDNs (like Replicate's) may block requests without proper User-Agent
3. **Empty file check:** Catches cases where download returns 200 OK but empty body
4. **Error visibility:** Upgraded from `logger.warn` to `logger.error` with "CRITICAL" prefix

### Verification steps

1. Generate an image
2. Check server logs for "Saved image output to" message (not "CRITICAL: Failed")
3. Verify `/data/workflows/{workflowId}/output/` contains the file
4. Verify the frontend shows URL starting with `http://localhost:3001/api/files/` not `replicate.delivery`
5. Clear browser cache and reload - image should still display

### Next steps

- [ ] Monitor logs for any remaining "CRITICAL: Failed to save output" errors
- [ ] If errors persist, investigate specific Replicate CDN requirements

---

## Session 25: Fix imageGen to imageGen Node Connection

**Status:** Complete

### Problem

User cannot connect the output of one imageGen (Nano Banana Pro) node to the input of another imageGen node. The connection line appears during drag but won't attach to the target.

### System Flow

```
┌─────────────┐     image      ┌─────────────┐
│  imageGen   │───────────────▶│  imageGen   │
│   (NBP1)    │   output       │   (NBP2)    │
│             │                │   images    │
└─────────────┘                │   input     │
                               └─────────────┘
                                     │
                                     ▼
                               ┌─────────────┐
                               │  Replicate  │
                               │     API     │
                               └─────────────┘
```

### Root Causes

1. **Connection not allowed for handles with existing connections** - `findCompatibleHandle` was skipping handles that already had connections, even if they supported `multiple: true`
2. **Input handles missing `isConnectableEnd` prop** - React Flow needs explicit permission to connect
3. **Output URLs not converted to base64** - The regex in `urlToBase64` only matched `/input/` paths, not `/output/` paths
4. **Remote URLs not converted** - Replicate delivery URLs weren't being converted to base64

### What was done

- [x] Fixed `findCompatibleHandle` to allow connections to handles with `multiple: true`
- [x] Added `isConnectableEnd` prop to input handles in BaseNode
- [x] Fixed `urlToBase64` regex to match both `/input/` and `/output/` paths
- [x] Added `urlToBase64Async()` method for converting remote URLs via fetch
- [x] Updated image processor to use async conversion for all input images

### Files changed

**Modified:**
- `apps/web/src/store/workflow/slices/edgeSlice.ts` - Fixed `findCompatibleHandle` to not skip handles with `multiple: true`
- `apps/web/src/components/nodes/BaseNode.tsx` - Added `isConnectableEnd={!isDisabled}` to input handles
- `apps/web/src/components/canvas/WorkflowCanvas.tsx` - Added debug logging (then removed)
- `apps/api/src/services/files.service.ts` - Fixed regex, added `urlToBase64Async` and `urlsToBase64Async`
- `apps/api/src/processors/image.processor.ts` - Changed to use `urlsToBase64Async` for all input images

### Technical Details

**Connection fix (edgeSlice.ts:121-124):**
```typescript
// Skip handles that already have connections, unless they support multiple connections
const hasExistingConnection = existingTargetHandles.has(input.id);
if (hasExistingConnection && !input.multiple) continue;
```

**URL conversion fix (files.service.ts):**
```typescript
// Before: only matched /input/
const match = url.match(/\/api\/files\/workflows\/([^/]+)\/input\/([^/?#]+)/);

// After: matches both /input/ and /output/
const match = url.match(/\/api\/files\/workflows\/([^/]+)\/(input|output)\/([^/?#]+)/);
```

**Async conversion for remote URLs:**
```typescript
async urlToBase64Async(url: string): Promise<string> {
  // Try local conversion first
  if (url.includes('/api/files/workflows/')) {
    const localResult = this.urlToBase64(url);
    if (localResult.startsWith('data:')) return localResult;
  }
  // Remote URL - fetch and convert
  const response = await fetch(url, { headers: { 'User-Agent': 'Genfeed/1.0' } });
  const buffer = Buffer.from(await response.arrayBuffer());
  return `data:${contentType};base64,${buffer.toString('base64')}`;
}
```

### Decisions

- **Decision:** Add async URL conversion with remote URL support
  - **Context:** Sometimes output save fails and Replicate URLs are stored instead of local URLs
  - **Rationale:** Ensures all images are converted to base64 regardless of whether they're local or remote

### Verification

User confirmed:
1. Connection now works between imageGen nodes
2. Images are being sent to Replicate API in the input payload
3. After using `urlsToBase64Async`, both local and remote URLs will be converted to base64

### Next steps

- [ ] Monitor that all images are converted to base64 (no raw URLs in Replicate payloads)
- [ ] Consider updating video processor similarly if video-to-video connections are needed

---

## Session 10: AI Influencer Avatar Workflow Template

**Status:** Complete

### System Flow

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Avatar    │────▶│  LLM Avatar │────▶│  ImageGen   │──┬──▶ Output Avatar
│   Prompt    │     │   Refine    │     │   Avatar    │  │
└─────────────┘     └─────────────┘     └─────────────┘  │
                                                          │
                    ┌─────────────────────────────────────┘
                    │ (avatar reference feeds all scenes)
                    │
┌─────────────┐     │     ┌─────────────┐     ┌─────────────┐
│   Scene 1   │─────┼────▶│  ImageGen   │────▶│  Output 1   │
│   Prompt    │     │     │   Scene 1   │     │  (Beach)    │
└─────────────┘     │     └─────────────┘     └─────────────┘
                    │
┌─────────────┐     │     ┌─────────────┐     ┌─────────────┐
│   Scene 2   │─────┼────▶│  ImageGen   │────▶│  Output 2   │
│   Prompt    │     │     │   Scene 2   │     │  (Office)   │
└─────────────┘     │     └─────────────┘     └─────────────┘
                    │
┌─────────────┐     │     ┌─────────────┐     ┌─────────────┐
│   Scene 3   │─────┼────▶│  ImageGen   │────▶│  Output 3   │
│   Prompt    │     │     │   Scene 3   │     │  (Outdoor)  │
└─────────────┘     │     └─────────────┘     └─────────────┘
                    │
┌─────────────┐     │     ┌─────────────┐     ┌─────────────┐
│   Scene 4   │─────┴────▶│  ImageGen   │────▶│  Output 4   │
│   Prompt    │           │   Scene 4   │     │  (Casual)   │
└─────────────┘           └─────────────┘     └─────────────┘
```

### What was done

- [x] Created AI Influencer Avatar workflow template
- [x] 16 nodes: 5 prompts, 1 LLM, 5 imageGen, 5 output
- [x] 15 edges: avatar chain + 4 parallel scene variations with reference
- [x] Registered template in index.ts with TEMPLATE_REGISTRY, TEMPLATE_INFO, and exports

### Files changed

| File | Change |
|------|--------|
| `apps/web/src/templates/generated/ai-influencer-avatar.ts` | Created - Full workflow template with 16 nodes and 15 edges |
| `apps/web/src/templates/index.ts` | Added import, registry entry, template info, and export |

### Template Structure

**Nodes (16 total):**
- `prompt-avatar` - Avatar description input
- `llm-avatar` - Refines avatar prompt for image generation
- `imagegen-avatar` - Generates base avatar (1:1 aspect ratio)
- `output-avatar` - Base avatar output
- `prompt-scene-1` through `prompt-scene-4` - Beach, Office, Outdoor, Casual scenes
- `imagegen-scene-1` through `imagegen-scene-4` - Scene variations (4:5 aspect ratio)
- `output-scene-1` through `output-scene-4` - Scene outputs

**Edges (15 total):**
- Avatar chain: prompt → LLM → imageGen → output (3 edges)
- Scene prompts to imageGen (4 edges)
- Avatar reference to all scene imageGen nodes via `images` handle (4 edges)
- Scene imageGen to outputs (4 edges)

### Decisions

- **Decision:** Use 1:1 aspect ratio for base avatar, 4:5 for scene variations
  - **Rationale:** 1:1 is standard for avatar/profile images, 4:5 is optimal for Instagram/social posts

- **Decision:** Connect avatar to scenes via `images` handle (not `prompt`)
  - **Rationale:** The `images` handle is used for character reference/consistency, prompts describe the scene

### Patterns Followed

- Followed existing template structure from `instagram-carousel.ts`
- Used consistent node data patterns (status: 'idle', jobId: null, etc.)
- Alphabetical import ordering in index.ts
- Category: 'images' for image-focused workflow

### Next steps

- [ ] Test template in Studio UI
- [ ] Verify all 16 nodes render correctly
- [ ] Verify all 15 edges connect properly
- [ ] Test execution flow end-to-end

---

## Session 27: Integrate flux-kontext-dev Model with Base64 Image Support

**Duration:** ~10 minutes
**Status:** Complete

### Summary

Integrated `black-forest-labs/flux-kontext-dev` model for image editing/generation. This model uses a singular `input_image` field (string) instead of an array, which required schema mapper updates to handle the type difference.

### System Flow

```
ImageGenNode → inputImages[] → SchemaMapper → input_image (singular) → Replicate API
                                    ↓
                         Check schema.type !== 'array'
                                    ↓
                         Pass inputImages[0] instead of array
```

### What was done

- [x] Added `input_image` to schema mapper alternatives (before `image_input`)
- [x] Updated `mapImageInput()` to detect singular vs array image fields
- [x] Added `fluxKontextDev` to MODELS constant in replicate.service.ts
- [x] Added `input_image` to urlKeys for base64 conversion in schemaParams
- [x] Added model metadata in frontend route.ts
- [x] Added model to sync script MODELS_TO_SYNC
- [x] Ran `bun run sync:replicate` - successfully fetched schema

### Files changed

| File | Change |
|------|--------|
| `apps/api/src/services/schema-mapper.service.ts` | Added `input_image` to alternatives, added singular vs array detection in `mapImageInput()` |
| `apps/api/src/services/replicate.service.ts` | Added `fluxKontextDev` to MODELS, added `input_image` to urlKeys |
| `apps/web/src/app/api/providers/models/route.ts` | Added model metadata with capabilities `['text-to-image', 'image-to-image']` |
| `scripts/sync-replicate-schemas.ts` | Added flux-kontext-dev to MODELS_TO_SYNC |
| `packages/types/src/replicate/schemas.json` | Updated with flux-kontext-dev schema |
| `packages/types/src/replicate/models.ts` | Generated FluxKontextDevInput type |

### Key Decisions

- **Decision:** Check `fieldSchema.type === 'array'` to determine singular vs array handling
  - **Rationale:** flux-kontext-dev schema shows `"type": "string"` for `input_image`, not `"type": "array"`
  - **Impact:** If not array type, pass `inputImages[0]` instead of full array

- **Decision:** Add `input_image` before `image_input` in alternatives
  - **Rationale:** Order matters - first match wins. `input_image` is the specific field name for flux-kontext-dev

### Technical Details

**flux-kontext-dev schema key points:**
- `input_image` is **required** (not optional)
- `type: "string"` with `format: "uri"`
- Accepts base64 data URIs (already handled by `urlToBase64()`)

**Schema mapper change:**
```typescript
// Check if schema expects array or single value
const fieldSchema = schemaProps[fieldName];
const expectsArray = fieldSchema?.type === 'array';
result[fieldName] = expectsArray ? input.inputImages : input.inputImages[0];
```

### Patterns Established

- When adding models with different field structures, check schema type to handle singular vs array
- Always add new URL field names to `urlKeys` array for base64 conversion
- Run `sync:replicate` after adding models to MODELS_TO_SYNC

### Next steps

- [ ] Test flux-kontext-dev in ImageGenNode
- [ ] Verify base64 image is sent correctly to Replicate
- [ ] Test image editing capability (prompt + input image)

---

## Session 26: Add Seed Data to Prompts Library

**Duration:** ~15 minutes
**Status:** Complete

### System Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                    PROMPT SEEDING FLOW                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  API Startup                                                    │
│      │                                                          │
│      ▼                                                          │
│  PromptsService.onModuleInit()                                  │
│      │                                                          │
│      ▼                                                          │
│  seedSystemPrompts()                                            │
│      │                                                          │
│      ├─── For each SYSTEM_PROMPTS entry:                        │
│      │        │                                                 │
│      │        ▼                                                 │
│      │    Find existing by { name, isSystem: true }             │
│      │        │                                                 │
│      │        ├─── EXISTS: Update with $set                     │
│      │        │                                                 │
│      │        └─── NOT EXISTS: Create new document              │
│      │                                                          │
│      ▼                                                          │
│  Log "Seeded X new prompt(s)"                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

Frontend Flow:
┌─────────────────────────────────────────────────────────────────┐
│  PromptNode                                                     │
│      │                                                          │
│      ├─── "Load from Library" dropdown → PromptPicker           │
│      │        │                                                 │
│      │        ▼                                                 │
│      │    promptsApi.getAll() → GET /prompts                    │
│      │        │                                                 │
│      │        ▼                                                 │
│      │    Shows 12 seeded prompts + user prompts                │
│      │                                                          │
│      └─── "Save to Library" button → CreatePromptModal          │
│               │                                                 │
│               ▼                                                 │
│           promptsApi.create() → POST /prompts                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### What was done

- [x] Created `apps/api/src/templates/prompts.seed.ts` with 12 curated system prompts
- [x] Added `isSystem: boolean` field to prompt schema
- [x] Added `isSystem: boolean` to IPrompt type interface
- [x] Implemented `OnModuleInit` in PromptsService with `seedSystemPrompts()` method
- [x] Updated PromptNode to include `isSystem: false` when saving to library

### Files created

| File | Description |
|------|-------------|
| `apps/api/src/templates/prompts.seed.ts` | 12 curated system prompts across categories |

### Files changed

| File | Change |
|------|--------|
| `apps/api/src/schemas/prompt.schema.ts` | Added `isSystem: boolean` field (line 69-70) |
| `packages/types/src/prompts.ts` | Added `isSystem: boolean` to IPrompt interface (line 44) |
| `apps/api/src/services/prompts.service.ts` | Added OnModuleInit, Logger, seedSystemPrompts() method |
| `apps/web/src/components/nodes/input/PromptNode.tsx` | Added `isSystem: false` to openCreateModal object |

### Prompt Categories

12 prompts across categories:
- **Portrait (3):** Cinematic Portrait, Fashion Editorial, Environmental Portrait
- **Product (2):** E-commerce Product Shot, Lifestyle Product
- **Landscape (2):** Golden Hour Landscape, Moody Landscape
- **Anime (1):** Anime Character (Studio Ghibli style)
- **Food (1):** Food Photography
- **Abstract (1):** Abstract Art
- **Ads/Marketing (2):** Social Media Ad, Hero Banner

### Decisions

- **Decision:** Follow same pattern as templates.service.ts for seeding
  - **Rationale:** Consistency across codebase, proven pattern works

- **Decision:** Use `isSystem: true` flag to identify seeded prompts
  - **Rationale:** Allows updating seeds without duplicating, distinguishes from user-created prompts

- **Decision:** All seeded prompts are `isFeatured: true`
  - **Rationale:** They should appear in featured section for discoverability

### Patterns Followed

- Same seeding pattern as `templates.service.ts`
- OnModuleInit lifecycle hook for seeding
- Logger for seed confirmation messages
- Upsert logic: find by { name, isSystem: true }, update if exists, create if not

### Verification Steps

1. Start API server (`bun run dev -- --projects=api`)
2. Check logs for "Seeded 12 new prompt(s)"
3. Open Studio, add a Prompt node
4. Click "Load from Library" dropdown - should show 12 prompts
5. Select one - should populate the prompt field
6. Test "Save to Library" button - should open modal with prompt pre-filled

### Next steps

- [ ] Test seeding on API startup
- [ ] Verify prompts appear in dropdown
- [ ] Test save prompt functionality end-to-end


---

## Session 29: Multi-Image Output Support for SeedDream 4.5

**Status:** Complete

### System Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                        REPLICATE API                                 │
│  Model returns: ["url1.png", "url2.png", "url3.png", "url4.png"]    │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                     IMAGE PROCESSOR (Backend)                        │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ Array.isArray(output) && output.length > 1?                  │   │
│  │   YES → downloadAndSaveMultipleOutputs()                     │   │
│  │         Save as: {predictionId}-0.png, -1.png, -2.png...     │   │
│  │         Output: { image: url[0], images: [url0, url1, ...] } │   │
│  │   NO  → downloadAndSaveOutput() (existing single-image)      │   │
│  └─────────────────────────────────────────────────────────────┘   │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                   OUTPUT HELPERS (Frontend Store)                    │
│  extractAllOutputValues(output) → string[]                          │
│  getOutputUpdate() → { outputImage: first, outputImages: all }      │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    IMAGEGEN NODE (Frontend UI)                       │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ outputImages.length > 1?                                     │   │
│  │   YES → Gallery UI (2-col grid, thumbnails, download all)    │   │
│  │   NO  → Single image preview (existing behavior)             │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

### What was done

- [x] Added `downloadAndSaveMultipleOutputs()` method to FilesService for batch saving
- [x] Updated ImageProcessor to detect and handle multi-image array outputs
- [x] Added `outputImages: string[]` field to ImageGenNodeData type
- [x] Updated NODE_DEFINITIONS default data with `outputImages: []`
- [x] Added `extractAllOutputValues()` helper in outputHelpers.ts
- [x] Updated `getOutputUpdate()` to populate both `outputImage` and `outputImages`
- [x] Added gallery UI to ImageGenNode for multiple images (following ImageGridSplitNode pattern)

### Files changed

| File | Change |
|------|--------|
| `apps/api/src/services/files.service.ts` | Added `downloadAndSaveMultipleOutputs()` method |
| `apps/api/src/processors/image.processor.ts` | Refactored to handle multi-image array outputs, batch save all images |
| `packages/types/src/nodes.ts` | Added `outputImages: string[]` to ImageGenNodeData and default data |
| `apps/web/src/store/execution/helpers/outputHelpers.ts` | Added `extractAllOutputValues()`, updated `getOutputUpdate()` for imageGen |
| `apps/web/src/components/nodes/ai/ImageGenNode.tsx` | Added gallery UI with thumbnails, download buttons, preview expand |

### Decisions

- **Decision:** Maintain backward compatibility with `outputImage` field
  - **Rationale:** Existing workflows and downstream nodes expect single `outputImage` field; new `outputImages` array is additive

- **Decision:** Follow ImageGridSplitNode pattern for gallery UI
  - **Rationale:** Proven pattern with thumbnails, click-to-expand, and download all functionality

- **Decision:** Save files with indexed naming: `{predictionId}-0.png`, `-1.png`, etc.
  - **Rationale:** Maintains prediction ID traceability while supporting multiple outputs

### Patterns Established

- Multi-output handling: always provide both singular (first item) and plural (all items) fields
- Gallery UI pattern: 2-col grid, numbered thumbnails, hover download, click-to-expand preview
- Batch file operations: iterate with indexed naming for traceability

### Next steps

- [ ] Test with single-output model (verify existing behavior unchanged)
- [ ] Test with SeedDream 4.5 or mock multi-image response
- [ ] Verify all images saved with indexed names
- [ ] Verify gallery UI displays correctly with 2, 3, 4+ images
- [ ] Verify "Download All" works
- [ ] Verify downstream connections still receive first image via `outputImage`

---

## Session 30: Fix Schema Inputs Not Showing on Template Load

**Duration:** ~10 minutes
**Status:** Complete

### Problem

When loading a workspace with a template, ImageGenNode and VideoGenNode didn't show schema inputs (aspect_ratio, resolution, duration, etc.) until the user manually changed the model.

### Root Cause

- Templates/workflows store `model: 'nano-banana-pro'` (short internal name) but **no `selectedModel` object**
- Schema inputs only render when `nodeData.selectedModel?.inputSchema` exists
- The `useModelSelection` hook properly sets `selectedModel` when users change models - that's why manual change fixes it
- But on initial load, `selectedModel` is undefined, so schema inputs don't render

### Solution

Hydrate nodes with `selectedModel` data when loading workflows/templates by looking up schemas from the cached registry.

### Files Created

| File | Description |
|------|-------------|
| `apps/web/src/lib/utils/nodeHydration.ts` | Utility to hydrate nodes with schema data on load |

### Files Changed

| File | Change |
|------|--------|
| `apps/web/src/store/workflow/slices/persistenceSlice.ts` | Import and use `hydrateWorkflowNodes()` in `loadWorkflow()` and `loadWorkflowById()` |

### Implementation Details

1. Created `nodeHydration.ts` with:
   - `MODEL_TO_REPLICATE_ID` mapping: `'nano-banana-pro' → 'google/nano-banana-pro'`
   - `lookupModelSchema()` function to find schema from `schemas.json` by internal model name
   - `hydrateWorkflowNodes()` function that:
     - Only processes imageGen and videoGen nodes
     - Skips nodes that already have `selectedModel.inputSchema`
     - Populates `selectedModel` with schema data
     - Sets `schemaParams` to defaults if empty

2. Updated `persistenceSlice.ts`:
   - `loadWorkflow()` - hydrates template nodes before setting state
   - `loadWorkflowById()` - hydrates workflow nodes before setting state

### Patterns Used

- Followed existing `schemaUtils.ts` patterns for default extraction
- Used same `SelectedModel` type from `@genfeedai/types`
- Imported schemas directly from `@genfeedai/types/replicate/schemas.json`

### Testing Checklist

- [ ] Load any template with an ImageGenNode - verify schema inputs appear immediately
- [ ] Load any template with a VideoGenNode - verify schema inputs appear immediately  
- [ ] Save workflow, reload page - verify schema inputs persist
- [ ] Manually change model - verify it still works as before
- [ ] Verify image input handle enabled/disabled based on model support

---

## Session 30: Fix Second Image Node Output Not Saved to Disk

**Duration:** ~5 minutes
**Status:** Complete

### Problem

In workflows with two image generation nodes (e.g., Nano Banana → Nano Banana), only the first node's output was saved to `/data/workflows/{id}/output/`. The second node displayed its image from Replicate's temporary URL but the file was NOT persisted locally.

### Root Cause

1. **Misleading type cast** in `replicate-poller.service.ts:104` - `prediction.output as Record<string, unknown>` masked that Replicate can return different output formats
2. **Missing fallback extraction** in `image.processor.ts` - when output format didn't match known patterns, it passed through without attempting to save

### System Flow

```mermaid
flowchart LR
    A[Replicate API] -->|output: string/array/object| B[ReplicatePollerService]
    B -->|JobResult.output| C[ImageProcessor]
    C -->|format detection| D{Output Format?}
    D -->|array| E[Save all URLs]
    D -->|string| F[Save single URL]
    D -->|object.image| G[Save image field]
    D -->|unknown| H[NEW: Extract URL with regex]
    H -->|found| I[Save extracted URL]
    H -->|not found| J[Pass through raw]
```

### What was done

- [x] Updated `JobResult.output` type from `Record<string, unknown>` to `string | string[] | Record<string, unknown>`
- [x] Removed misleading type cast `as Record<string, unknown>` in replicate-poller.service.ts
- [x] Added debug logging for output format in image.processor.ts
- [x] Added fallback URL extraction using regex for unknown output formats

### Files changed

| File | Change |
|------|--------|
| `apps/api/src/interfaces/job-data.interface.ts` | Expanded `JobResult.output` type to union type |
| `apps/api/src/services/replicate-poller.service.ts` | Removed type cast at line 104 |
| `apps/api/src/processors/image.processor.ts` | Added logging (lines 128-132) and fallback URL extraction (lines 256-290) |

### Key Decisions

- **Decision:** Use regex extraction as fallback for unknown formats
  - **Rationale:** Different Replicate models return different formats; better to attempt extraction than silently fail to save
  - **Pattern:** `https?:\/\/[^\s"']+\.(jpg|jpeg|png|webp|gif)`

- **Decision:** Add logging before format detection
  - **Rationale:** Helps debug which format each node returns without requiring code changes

### Verification Steps

- [ ] Run workflow with two connected Nano Banana nodes
- [ ] Check server logs for new format logging
- [ ] Verify both files appear in `/data/workflows/{id}/output/`
- [ ] Verify both nodes show `localhost:3001/api/files/...` URLs (not `replicate.delivery/...`)

### Next steps

- [ ] Test with various Replicate models to ensure fallback works
- [ ] Consider adding more specific format handlers if patterns emerge


---

## Session 32: Remove Community Models from Replicate Integration

**Duration:** ~15 minutes
**Status:** Complete

### System Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                     REPLICATE MODEL CLASSIFICATION                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  ┌─────────────────────────────┐   ┌─────────────────────────────┐  │
│  │     OFFICIAL MODELS         │   │     COMMUNITY MODELS         │  │
│  │                             │   │                             │  │
│  │  API: /v1/models/{owner}/   │   │  API: /v1/predictions       │  │
│  │       {name}/predictions    │   │       + version hash        │  │
│  │                             │   │                             │  │
│  │  ✅ google/nano-banana      │   │  ❌ stability-ai/sdxl       │  │
│  │  ✅ black-forest-labs/flux  │   │  ❌ bytedance/sdxl-lightning│  │
│  │  ✅ google/veo-3.1          │   │  ❌ bytedance/latentsync    │  │
│  │  ✅ sync/lipsync-2          │   │                             │  │
│  │  ✅ pixverse/lipsync        │   │                             │  │
│  └─────────────────────────────┘   └─────────────────────────────┘  │
│              │                                  │                     │
│              ▼                                  ▼                     │
│        Works with                        Causes 404 error             │
│    replicate.predictions.create()   (requires version hash)          │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### What was done

- [x] Audited all 22 Replicate models in the codebase via web fetch
- [x] Identified 3 community models causing 404 errors (require version hash)
- [x] Removed `stability-ai/sdxl` from all files
- [x] Removed `bytedance/sdxl-lightning-4step` from all files
- [x] Removed `bytedance/latentsync` from all files
- [x] Updated LipSyncModel type to only include official models
- [x] Updated tests to reflect removed models

### Files changed

| File | Change |
|------|--------|
| `scripts/sync-replicate-schemas.ts` | Removed 3 community models from MODELS_TO_SYNC |
| `apps/web/src/app/api/providers/models/route.ts` | Removed SDXL models from MODEL_METADATA |
| `apps/api/src/services/replicate.service.ts` | Removed latentSync from MODELS and LIP_SYNC_MODEL_MAP, updated LipSyncInput type |
| `apps/web/src/components/nodes/ai/LipSyncNode.tsx` | Removed LatentSync from model dropdown |
| `apps/web/src/lib/replicate/client.ts` | Removed latentSync from MODELS, PRICING, LipSyncModel type, and modelMap |
| `apps/web/src/lib/replicate/client.test.ts` | Removed latentSync from model and pricing tests |
| `packages/types/src/nodes.ts` | Removed `bytedance/latentsync` from LipSyncModel type |
| `apps/api/src/interfaces/job-data.interface.ts` | Removed `bytedance/latentsync` from LipSyncJobData model type |

### Decisions

- **Decision:** Remove community models rather than add version-based support
  - **Context:** stability-ai/sdxl was returning 404 because Replicate's official model API endpoint doesn't work for community models
  - **Rationale:** SDXL and SDXL-Lightning are outdated (FLUX models are superior), and adding version-based support adds complexity for minimal benefit

- **Decision:** Keep only official Replicate models
  - **Rationale:** Official models use simpler API (`/v1/models/{owner}/{name}/predictions`), are always-on, maintained, and have predictable pricing

### Models Audit Results

**Official (19):** google/nano-banana, google/nano-banana-pro, prunaai/z-image-turbo, black-forest-labs/flux-schnell, black-forest-labs/flux-dev, black-forest-labs/flux-1.1-pro, black-forest-labs/flux-kontext-dev, google/veo-3.1-fast, google/veo-3.1, kwaivgi/kling-v2.5-turbo-pro, kwaivgi/kling-v2.6-motion-control, minimax/video-01, luma/ray, meta/meta-llama-3.1-405b-instruct, luma/reframe-image, luma/reframe-video, sync/lipsync-2, sync/lipsync-2-pro, pixverse/lipsync

**Removed (3):** stability-ai/sdxl, bytedance/sdxl-lightning-4step, bytedance/latentsync

### Next steps

- [ ] Run `bun run sync:replicate` to regenerate types without removed models
- [ ] Test image generation with remaining models

---

## Session 33: Fix Output Files Not Saved During Single Node Execution

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Diagnosed why outputs weren't saved to `data/workflows/{id}/output/` during "Retry" or single node execution
- [x] Identified two separate execution paths with different file saving behavior
- [x] Fixed by adding file saving to the polling endpoint when workflowId is provided
- [x] Updated frontend to pass workflowId during prediction polling

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Two Execution Paths - Before vs After Fix                              │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  PATH 1: "Run Workflow" (Already worked)                               │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │ POST /workflows/:id/execute                                       │  │
│  │     → Queue → ImageProcessor.process()                            │  │
│  │     → FilesService.downloadAndSaveOutput()                        │  │
│  │     → ✅ Files saved to data/workflows/{id}/output/               │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│  PATH 2: "Retry" / Single Node (Bug was here)                          │
│  ┌──────────────────────────────────────────────────────────────────┐  │
│  │ BEFORE:                                                           │  │
│  │ POST /replicate/image → predictionId                              │  │
│  │     → Frontend polls GET /replicate/predictions/:id               │  │
│  │     → Returns Replicate URL directly                              │  │
│  │     → ❌ No file saving!                                          │  │
│  │                                                                    │  │
│  │ AFTER (Fixed):                                                    │  │
│  │ POST /replicate/image → predictionId                              │  │
│  │     → Frontend polls GET /replicate/predictions/:id               │  │
│  │       ?workflowId=xxx&nodeId=yyy                                  │  │
│  │     → Backend saves file when succeeded                           │  │
│  │     → ✅ Returns local URL, files saved                           │  │
│  └──────────────────────────────────────────────────────────────────┘  │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Root Cause

Two execution paths existed:
1. **Workflow execution** via queue → `ImageProcessor` calls `FilesService.downloadAndSaveOutput()`
2. **Single node execution** via direct API → `ReplicateController` returns predictionId → frontend polls → **never saved files**

The polling endpoint `GET /replicate/predictions/:id` only returned the Replicate-hosted URL without downloading or saving the file locally.

### Files changed

**Backend:**
- `apps/api/src/controllers/replicate.controller.ts`
  - Added `FilesService` dependency injection
  - Added `Logger` for error tracking
  - Modified `getPredictionStatus()` to accept optional `workflowId` and `nodeId` query params
  - When prediction succeeds AND params provided: downloads file, saves to local storage, returns local URL

**Frontend:**
- `apps/web/src/store/execution/helpers/pollPrediction.ts`
  - Now passes `workflowId` and `nodeId` as query params when polling
  - Gets workflowId from `workflowStore.workflowId`

### Technical Details

**Backend endpoint change:**
```typescript
@Get('predictions/:id')
async getPredictionStatus(
  @Param('id') predictionId: string,
  @Query('workflowId') workflowId?: string,
  @Query('nodeId') nodeId?: string
) {
  const prediction = await this.replicateService.getPredictionStatus(predictionId);

  // If prediction succeeded and we have workflowId/nodeId, save the output locally
  if (prediction.status === 'succeeded' && workflowId && nodeId && prediction.output) {
    const saved = await this.filesService.downloadAndSaveOutput(
      workflowId, nodeId, output, predictionId
    );
    return { ...prediction, output: { image: saved.url, images: [saved.url] } };
  }

  return prediction;
}
```

**Frontend polling change:**
```typescript
const workflowId = workflowStore.workflowId;
const queryParams = workflowId ? `?workflowId=${workflowId}&nodeId=${nodeId}` : '';
const data = await apiClient.get(`/replicate/predictions/${predictionId}${queryParams}`);
```

### Decisions

- **Decision:** Add file saving to polling endpoint rather than creating new endpoint
  - **Rationale:** Minimal change, backward compatible (params are optional), single code path for saving

- **Decision:** Pass workflowId/nodeId as query params rather than requiring separate save call
  - **Rationale:** Simpler frontend code, atomic operation (poll + save in one request)

### Open Question (Deferred)

User asked if `/replicate/image` endpoint is still needed. Could potentially:
1. Keep it (current): Two paths, both now save files
2. Remove it: Route single-node execution through workflow queue
3. Consolidate: Have endpoint do everything (create + poll + save) synchronously

Decision deferred for future consideration.

### Next steps

- [ ] Consider consolidating execution paths in future refactor
- [ ] Test with various models to verify file saving works for all output formats

---

## Session 33: Add 11 Missing Templates to Backend Seed File

**Duration:** ~15 minutes
**Status:** Complete

### System Flow

```
┌─────────────────────────────────────────────────────────────────────┐
│                    TEMPLATE SEEDING ARCHITECTURE                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                       │
│  Frontend Templates              Backend Seed              Database   │
│  ─────────────────              ───────────              ─────────   │
│                                                                       │
│  apps/web/src/templates/        apps/api/src/templates/   MongoDB    │
│  generated/*.ts                 templates.seed.ts         templates  │
│       │                              │                        ▲      │
│       │                              │                        │      │
│       └──────────────────────────────┘                        │      │
│                    │                                          │      │
│                    ▼                                          │      │
│            Template Explorer UI ◄─────────────────────────────┘      │
│            (fetches from DB)                                         │
│                                                                       │
│  Problem: 11 templates existed in frontend but not in seed file      │
│  Solution: Added all 11 templates to SYSTEM_TEMPLATES array          │
│                                                                       │
└─────────────────────────────────────────────────────────────────────┘
```

### What was done

- [x] Read all 11 frontend template files from `apps/web/src/templates/generated/`
- [x] Converted WorkflowFile format to seed format (removed createdAt/updatedAt)
- [x] Added all 11 templates to `SYSTEM_TEMPLATES` array in backend seed file
- [x] Verified all edge targetHandle values use correct handle IDs

### Templates Added

| # | Template Name | Category | Source File |
|---|---------------|----------|-------------|
| 1 | Extended Video Pipeline | video | `extended-video.ts` |
| 2 | Grid to Video Pipeline | full-pipeline | `grid-to-video.ts` |
| 3 | Voice to Video | audio | `voice-to-video.ts` |
| 4 | YouTube Thumbnail & Script Generator | images | `youtube-thumbnail-script.ts` |
| 5 | YouTube 10-Min Video Generator | full-pipeline | `youtube-video-generator.ts` |
| 6 | Stream to Short-Form Content | full-pipeline | `stream-to-social.ts` |
| 7 | Social Media Brand Kit | images | `social-brand-kit.ts` |
| 8 | Facecam Avatar | video | `facecam-avatar.ts` |
| 9 | Dance Video | video | `dance-video.ts` |
| 10 | Instagram Carousel | images | `instagram-carousel.ts` |
| 11 | AI Influencer Avatar | images | `ai-influencer-avatar.ts` |

### Files changed

| File | Change |
|------|--------|
| `apps/api/src/templates/templates.seed.ts` | Added 11 template definitions to SYSTEM_TEMPLATES array |

### Template Count

- **Before:** 12 templates
- **After:** 23 templates

### Technical Notes

- Templates seed on API server startup via `onModuleInit`
- YouTube 10-Min Video Generator was simplified from 20 scenes to 5 scenes for manageable seed file size
- All templates use `edgeStyle: 'smoothstep'` to match existing templates
- Edge handles use correct IDs: `'video'`, `'image'`, `'images'`, `'prompt'`, `'text'`, `'audio'`

### Decisions

- **Decision:** Simplify YouTube Video Generator from 20 to 5 scenes
  - **Context:** Original template had 20 image+video nodes (40 AI nodes total)
  - **Rationale:** Keep seed file manageable while demonstrating the pattern; users can expand as needed

### Verification Steps

1. Restart API server (templates seed on startup)
2. Open Template Explorer in UI
3. Verify all 11 new templates appear
4. Test loading facecam-avatar and dance-video templates
5. Verify nodes and edges render correctly

### Next steps

- [ ] Verify templates appear in Template Explorer after API restart
- [ ] Test loading templates into canvas
- [ ] Fix any edge handle mismatches if discovered during testing

---

## Session 34: TemplateCategory Enum Refactor

### Summary

Refactored template categories from hardcoded strings to a typed enum for type safety and consistency.

### Changes Made

1. **Created `TemplateCategory` enum** in `packages/types/src/enums.ts`
   - Values: `'text'`, `'image'`, `'video'`, `'audio'`, `'social'`, `'marketing'`, `'other'`
   - Changed `'images'` → `'image'` for consistency

2. **Updated 8 files** to use the enum:
   - `packages/types/src/enums.ts` - enum definition
   - `packages/types/src/index.ts` - export
   - `apps/api/src/schemas/template.schema.ts` - schema field
   - `apps/api/src/services/template-seeder.service.ts` - seed data
   - `apps/web/src/app/(workspace)/templates/_components/template-explorer.tsx` - filter UI
   - `apps/web/src/app/(workspace)/templates/_components/template-filter-bar.tsx` - filter logic

3. **Fixed Mongoose type inference error**
   - Error: `CannotDetermineTypeError: Cannot determine a type for the "Template.category" field`
   - Fix: Added `type: String` to `@Prop` decorator

### Technical Details

```typescript
// Before (broken)
@Prop({ required: true, enum: Object.values(TemplateCategory) })
category: TemplateCategory;

// After (fixed)
@Prop({ type: String, required: true, enum: Object.values(TemplateCategory) })
category: TemplateCategory;
```

Mongoose cannot infer the storage type from TypeScript enums. The explicit `type: String` tells Mongoose to store values as strings in MongoDB.

### Decisions

- **Decision:** Use `'image'` instead of `'images'`
  - **Rationale:** Consistent with other singular category names (`'text'`, `'video'`, `'audio'`)

---

## Session 35: Fix Prompt → TextToSpeech Connection Not Working

**Duration:** ~15 minutes
**Status:** Complete

### Problem

User connected a Prompt node to a Text to Speech node, but the connection wasn't being recognized. The TextToSpeech node still showed "Connect text input to generate speech" despite the visible edge connection.

### Root Cause Analysis

```
┌────────────────────────────────────────────────────────────────────────┐
│  Connection Propagation Flow (BEFORE - BROKEN)                          │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Prompt Node                    TextToSpeech Node                       │
│  ┌─────────────────┐           ┌─────────────────┐                     │
│  │ data.prompt     │──edge────▶│ data.inputText  │                     │
│  │ "Hello..."      │           │ null ❌          │                     │
│  └─────────────────┘           └─────────────────┘                     │
│                                                                         │
│  Problems:                                                              │
│  1. getNodeOutput() didn't check data.prompt                           │
│  2. mapOutputToInput() only handled 'output' node type                 │
│  3. No propagation on edge creation or data change                     │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Solution

```
┌────────────────────────────────────────────────────────────────────────┐
│  Connection Propagation Flow (AFTER - FIXED)                            │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Prompt Node                    TextToSpeech Node                       │
│  ┌─────────────────┐           ┌─────────────────┐                     │
│  │ data.prompt     │──edge────▶│ data.inputText  │                     │
│  │ "Hello..."      │           │ "Hello..." ✅    │                     │
│  └─────────────────┘           └─────────────────┘                     │
│                                                                         │
│  Propagation Triggers:                                                  │
│  1. Edge created (onConnect) → propagate immediately                   │
│  2. Input node data changes (updateNodeData) → propagate               │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### What was done

- [x] Updated `getNodeOutput()` to extract values from input nodes: `data.prompt`, `data.extractedTweet`, `data.image`, `data.audio`
- [x] Added `getOutputType()` helper to determine output type (text/image/video/audio) from source node
- [x] Expanded `mapOutputToInput()` to handle all propagation scenarios:
  - Text → `inputText` (textToSpeech, subtitle)
  - Text → `inputPrompt` (imageGen, videoGen, llm, motionControl)
  - Image → `inputImage` or `inputImages`
  - Video → `inputVideo`
  - Audio → `inputAudio`
- [x] Updated `updateNodeData()` to call `propagateOutputsDownstream()` when input nodes change
- [x] Updated `onConnect()` to propagate immediately when connecting from input nodes

### Files changed

| File | Change |
|------|--------|
| `apps/web/src/store/workflow/slices/nodeSlice.ts` | Extended `getNodeOutput()`, added `getOutputType()`, expanded `mapOutputToInput()`, added propagation in `updateNodeData()` |
| `apps/web/src/store/workflow/slices/edgeSlice.ts` | Added propagation in `onConnect()` for input nodes |

### Technical Details

**Output type mapping:**
```typescript
getOutputType(sourceType):
  - 'prompt', 'llm', 'tweetParser', 'template', 'transcribe' → 'text'
  - 'imageGen', 'image', 'upscale', 'resize', 'reframe' → 'image'
  - 'videoGen', 'video', 'animation', 'lipSync', etc. → 'video'
  - 'textToSpeech', 'audio' → 'audio'
```

**Input nodes that trigger immediate propagation:**
```typescript
const inputNodeTypes = ['prompt', 'image', 'video', 'audio', 'template', 'tweetParser'];
```

### Decisions

- **Decision:** Propagate on both edge creation AND data change
  - **Context:** Input nodes don't "execute" like AI nodes - they're just data sources
  - **Rationale:** Ensures downstream nodes always have current values without requiring workflow execution

- **Decision:** Type-safe output mapping
  - **Context:** Different target nodes expect different field names (`inputText` vs `inputPrompt`)
  - **Rationale:** Single mapping function handles all cases based on source/target node types

### Next steps

- [ ] Test Prompt → TextToSpeech connection works after refresh
- [ ] Verify other propagations work (Image → VideoGen, LLM → ImageGen, etc.)

---

## Session 36: Fix "Run Selected" to Only Execute Selected Nodes

**Duration:** ~20 minutes
**Status:** Complete

### Problem

When user clicks "Run Selected" in the toolbar, the entire workflow executes instead of just the selected node(s). The backend had no knowledge of which nodes were selected.

### Root Cause Analysis

```
┌────────────────────────────────────────────────────────────────────────┐
│  BEFORE: Run Selected executes ALL nodes                               │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  Frontend                           Backend                            │
│  ┌─────────────────┐               ┌─────────────────┐                │
│  │ selectedNodeIds │               │ POST /execute   │                │
│  │ ["node-2"]      │──────────────▶│ { debugMode }   │                │
│  └─────────────────┘               │                 │                │
│                                    │ Executes ALL    │                │
│                                    │ nodes in workflow│                │
│                                    └─────────────────┘                │
│                                                                        │
│  Problem: selectedNodeIds never sent to backend                        │
└────────────────────────────────────────────────────────────────────────┘
```

### Solution

```
┌────────────────────────────────────────────────────────────────────────┐
│  AFTER: Run Selected executes ONLY selected nodes                      │
├────────────────────────────────────────────────────────────────────────┤
│                                                                        │
│  Frontend                           Backend                            │
│  ┌─────────────────┐               ┌─────────────────┐                │
│  │ selectedNodeIds │               │ POST /execute   │                │
│  │ ["node-2"]      │──────────────▶│ { debugMode,    │                │
│  │                 │               │   selectedNodeIds}│               │
│  │ executingNodeIds│◀──────────────│                 │                │
│  │ (for UI)        │               │ Filters pending │                │
│  └─────────────────┘               │ nodes to only   │                │
│                                    │ execute selected │                │
│                                    │ + dependencies   │                │
│                                    └─────────────────┘                │
│                                                                        │
│  Edge highlighting only animates edges for executing nodes             │
└────────────────────────────────────────────────────────────────────────┘
```

### What was done

- [x] Frontend: Pass `selectedNodeIds` in API call from `executeSelectedNodes()`
- [x] Backend: Add `selectedNodeIds: string[]` field to Execution schema
- [x] Backend: Accept `selectedNodeIds` in controller and pass through service/queue
- [x] Backend: Filter `pendingNodes` in workflow processor by `selectedNodeIds` (including dependencies)
- [x] Backend: Update `checkExecutionCompletion()` to complete when selected nodes done
- [x] Frontend: Track `executingNodeIds` state for edge highlighting
- [x] Frontend: Only animate edges connected to executing nodes during partial execution

### Files changed

| File | Change |
|------|--------|
| `apps/web/src/store/execution/slices/executionSlice.ts` | Pass `selectedNodeIds` in API, set `executingNodeIds` state |
| `apps/web/src/store/execution/types.ts` | Add `executingNodeIds: string[]` to ExecutionState |
| `apps/web/src/store/execution/executionStore.ts` | Add `executingNodeIds: []` to initial state |
| `apps/web/src/components/canvas/WorkflowCanvas.tsx` | Filter edge highlighting by `executingNodeIds` |
| `apps/api/src/schemas/execution.schema.ts` | Add `selectedNodeIds: string[]` field |
| `apps/api/src/interfaces/job-data.interface.ts` | Add `selectedNodeIds` to WorkflowJobData |
| `apps/api/src/controllers/executions.controller.ts` | Accept `selectedNodeIds` in request body |
| `apps/api/src/services/executions.service.ts` | Store `selectedNodeIds`, update completion check |
| `apps/api/src/services/queue-manager.service.ts` | Pass `selectedNodeIds` to enqueue functions |
| `apps/api/src/processors/workflow.processor.ts` | Filter `pendingNodes` by selection + deps |

### Technical Details

**Dependency resolution for partial execution:**
```typescript
// Recursively get all dependencies of selected nodes
const getAllDependencies = (nodeId, visited = new Set()) => {
  if (visited.has(nodeId)) return visited;
  visited.add(nodeId);
  const deps = dependencyMap.get(nodeId) ?? [];
  for (const dep of deps) {
    getAllDependencies(dep, visited);
  }
  return visited;
};

// Execution set = selected + all their dependencies
for (const nodeId of selectedNodeSet) {
  const allDeps = getAllDependencies(nodeId);
  for (const dep of allDeps) {
    executionSet.add(dep);
  }
}
```

**Completion check for partial execution:**
```typescript
if (selectedNodeIds && selectedNodeIds.length > 0) {
  const allSelectedComplete = selectedNodeIds.every(
    (nodeId) => completedIds.has(nodeId) || failedIds.has(nodeId)
  );
  if (allSelectedComplete) {
    // Mark execution complete
  }
}
```

### Decisions

- **Decision:** Include dependencies of selected nodes in execution scope
  - **Context:** If node B depends on node A, and only B is selected, A must run first
  - **Rationale:** Maintains correct execution order; dependencies can use cached outputs in future

- **Decision:** Track `executingNodeIds` in frontend state
  - **Context:** Edge highlighting needs to know which nodes are part of partial execution
  - **Rationale:** Cleaner than re-fetching from backend; immediate UI feedback

- **Decision:** Use Set-based filtering in processor
  - **Context:** Could have used array.includes() but inefficient for many nodes
  - **Rationale:** O(1) lookup for execution set membership

### Next steps

- [ ] Test partial execution with multi-node selection
- [ ] Verify edge highlighting only animates relevant edges
- [ ] Consider caching dependency outputs for future partial executions

---

## Session 36: TypeScript Type Errors & Motion Control Video Transfer Fix

**Duration:** ~45 minutes
**Status:** Complete

### Summary

Fixed multiple TypeScript type errors and implemented full Motion Control Video Transfer mode support for Kling AI.

### System Flow

```
┌────────────────────────────────────────────────────────────────────────────────┐
│  Motion Control Video Transfer Flow (NEW)                                       │
├────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  Frontend                          Backend                        Replicate    │
│  ┌──────────────┐                 ┌──────────────┐               ┌──────────┐ │
│  │ Image Input  │───image───────▶│              │               │          │ │
│  └──────────────┘                │              │               │          │ │
│  ┌──────────────┐                │ Video        │  baseInput    │ Kling    │ │
│  │ Video Input  │───inputVideo──▶│ Processor    │───────────────▶│ v2.6     │ │
│  └──────────────┘                │              │  {image,video}│ Motion   │ │
│  ┌──────────────┐                │              │               │ Control  │ │
│  │ Prompt       │───prompt──────▶│              │               │          │ │
│  └──────────────┘                └──────────────┘               └──────────┘ │
│                                                                                 │
│  1. resolveNodeInputs() maps video handle → inputVideo field                   │
│  2. video.processor.ts extracts inputVideo ?? video                            │
│  3. replicate.service.ts converts to base64, sets mode params                  │
│  4. Kling API processes video transfer                                          │
│                                                                                 │
└────────────────────────────────────────────────────────────────────────────────┘
```

### What Was Done

- [x] Fixed Mongoose `CannotDetermineTypeError` for Template.category enum
- [x] Fixed TypeScript errors in processors (type narrowing for `result.output`)
- [x] Fixed `error: null` vs `undefined` type mismatch in sseSubscription.ts
- [x] Fixed `nodeName` type error with `String()` wrapper
- [x] Added `video`, `inputVideo` fields to `MotionControlJobData`
- [x] Added `video_transfer` mode to `MotionControlInput` interface
- [x] Updated `generateMotionControlVideo()` to handle video transfer mode
- [x] Updated `video.processor.ts` to pass video to service
- [x] Added `motionControl` to video output nodes in `outputHelpers.ts`

### Files Changed

**Backend (apps/api/src/):**
- `schemas/template.schema.ts` - Added `type: String` to @Prop for enum
- `interfaces/job-data.interface.ts` - Added video fields, video_transfer mode
- `services/replicate.service.ts` - Added MotionControlInput.video, video transfer logic
- `services/replicate-poller.service.ts` - Cast prediction.output type
- `processors/video.processor.ts` - Extract and pass video, quality, keepOriginalSound
- `processors/image.processor.ts` - Type narrowing for result.output
- `processors/processing.processor.ts` - Type narrowing for result.output

**Frontend (apps/web/src/):**
- `store/execution/helpers/sseSubscription.ts` - null→undefined, String() for nodeName
- `store/execution/slices/executionSlice.ts` - String() for nodeName
- `store/execution/helpers/outputHelpers.ts` - Added `motionControl` to video output nodes

### Key Decisions

- **Decision:** Add `type: String` to Mongoose enum props
  - **Context:** Mongoose can't infer type from TypeScript enums
  - **Rationale:** Explicit storage type prevents runtime errors

- **Decision:** Use type narrowing instead of casting
  - **Context:** `result.output` is union type `string | string[] | Record<string, unknown>`
  - **Rationale:** Safer than `as` casts, preserves TypeScript checks

- **Decision:** Map `video` handle → `inputVideo` field
  - **Context:** Handle names differ from DTO field names
  - **Rationale:** Consistent with existing pattern (image → inputImage)

### Mistakes and Fixes

1. **Mistake:** Motion Control output not displaying
   - **Cause:** `motionControl` missing from video output nodes list in `outputHelpers.ts`
   - **Fix:** Added `motionControl` to the includes() array

2. **Mistake:** "video is required" error from Replicate
   - **Cause:** Video input not being passed from processor to service
   - **Fix:** Added video extraction and passing in video.processor.ts

### Patterns Established

1. **Type narrowing pattern for union types:**
   ```typescript
   const isOutputObject = result.output && typeof result.output === 'object' && !Array.isArray(result.output);
   const output = isOutputObject ? (result.output as Record<string, unknown>) : undefined;
   ```

2. **Handle-to-field mapping pattern:**
   - Handle: `video` → Field: `inputVideo`
   - Extraction: `data.nodeData.inputVideo ?? data.nodeData.video`

### Next Steps

- [ ] Test Motion Control with all modes (video_transfer, camera, trajectory, combined)
- [ ] Verify video preview displays after generation completes
- [ ] Consider adding video transfer progress estimation

---

## Session 12: Replace Native HTML Elements with shadcn/ui Components

**Duration:** ~30 minutes
**Status:** Complete

### Summary

Replaced all native `<select>`, `<input type="checkbox">`, and `<input type="range">` elements in node components with proper shadcn/ui primitives (Select, Checkbox, Slider) for consistent, polished UI.

### System Flow

```
┌─────────────────────────────────────────────────────────────┐
│                     Node Components                          │
├─────────────────────────────────────────────────────────────┤
│  Before:                    After:                          │
│  <select>           →       <Select> (shadcn)               │
│  <input checkbox>   →       <Checkbox> (shadcn)             │
│  <input range>      →       <Slider> (shadcn)               │
│                                                              │
│  Handler patterns:                                           │
│  onChange={e.target.value}  →  onValueChange={value}        │
│  onChange={e.target.checked} → onCheckedChange={checked}    │
│  onChange={e.target.value}  →  onValueChange={[val]}        │
└─────────────────────────────────────────────────────────────┘
```

### Affected Components

**Frontend:**
- SchemaInputs.tsx (dynamic schema rendering)
- 6 AI nodes (TextToSpeech, MotionControl, LipSync, VoiceChange, LLM, Transcribe)
- 9 Processing nodes (Upscale, VideoStitch, Subtitle, VideoTrim, Animation, ImageGridSplit, Reframe, Resize, VideoFrameExtract)
- 4 Composition/Input nodes (WorkflowRef, WorkflowInput, WorkflowOutput, Template)
- NegativePromptSelector (8 checkboxes)

### What was done

- [x] Installed shadcn/ui slider and checkbox components
- [x] Updated SchemaInputs.tsx with shadcn Select, Checkbox, Slider
- [x] Updated 6 AI node components
- [x] Updated 9 Processing node components
- [x] Updated 4 Composition/Input node components
- [x] Updated NegativePromptSelector with shadcn Checkbox

### Key Changes

1. **Handler Patterns Updated:**
   - Select: `(e: React.ChangeEvent<HTMLSelectElement>)` → `(value: string)`
   - Checkbox: `onChange` → `onCheckedChange` with type check for `boolean | 'indeterminate'`
   - Slider: `(e: React.ChangeEvent<HTMLInputElement>)` → `([value]: number[])`

2. **nodrag Class Added:**
   - All interactive elements have `nodrag` class to prevent React Flow node dragging

3. **Slider Value Format:**
   - shadcn Slider uses arrays: `value={[num]}`, `onValueChange={([val]) => ...}`

### Files Changed

**New Files:**
- `apps/web/src/components/ui/slider.tsx` (installed via shadcn)
- `apps/web/src/components/ui/checkbox.tsx` (installed via shadcn)

**Modified Files (20):**
- `apps/web/src/components/nodes/SchemaInputs.tsx`
- `apps/web/src/components/nodes/NegativePromptSelector.tsx`
- `apps/web/src/components/nodes/ai/TextToSpeechNode.tsx`
- `apps/web/src/components/nodes/ai/MotionControlNode.tsx`
- `apps/web/src/components/nodes/ai/LipSyncNode.tsx`
- `apps/web/src/components/nodes/ai/VoiceChangeNode.tsx`
- `apps/web/src/components/nodes/ai/LLMNode.tsx`
- `apps/web/src/components/nodes/ai/TranscribeNode.tsx`
- `apps/web/src/components/nodes/processing/UpscaleNode.tsx`
- `apps/web/src/components/nodes/processing/VideoStitchNode.tsx`
- `apps/web/src/components/nodes/processing/SubtitleNode.tsx`
- `apps/web/src/components/nodes/processing/VideoTrimNode.tsx`
- `apps/web/src/components/nodes/processing/AnimationNode.tsx`
- `apps/web/src/components/nodes/processing/ImageGridSplitNode.tsx`
- `apps/web/src/components/nodes/processing/ReframeNode.tsx`
- `apps/web/src/components/nodes/processing/ResizeNode.tsx`
- `apps/web/src/components/nodes/processing/VideoFrameExtractNode.tsx`
- `apps/web/src/components/nodes/composition/WorkflowRefNode.tsx`
- `apps/web/src/components/nodes/composition/WorkflowInputNode.tsx`
- `apps/web/src/components/nodes/composition/WorkflowOutputNode.tsx`
- `apps/web/src/components/nodes/input/TemplateNode.tsx`

### Decisions

1. **Decision:** Use shadcn primitives consistently across all node components
   - **Rationale:** Ensures consistent styling with design system, better accessibility, smoother interactions

2. **Decision:** Keep `nodrag` class on all interactive elements
   - **Rationale:** Prevents React Flow from capturing mouse events when interacting with form controls

3. **Decision:** Handle shadcn Checkbox `onCheckedChange` type carefully
   - **Rationale:** Returns `boolean | 'indeterminate'`, must type-check before using

### Patterns Established

1. **shadcn Select pattern:**
   ```tsx
   <Select value={nodeData.field} onValueChange={handleChange}>
     <SelectTrigger className="nodrag h-8 w-full">
       <SelectValue />
     </SelectTrigger>
     <SelectContent>
       {options.map((opt) => (
         <SelectItem key={opt.value} value={opt.value}>{opt.label}</SelectItem>
       ))}
     </SelectContent>
   </Select>
   ```

2. **shadcn Slider pattern:**
   ```tsx
   <Slider
     value={[nodeData.field]}
     min={0}
     max={100}
     step={1}
     onValueChange={([value]) => handleChange(value)}
     className="nodrag w-full"
   />
   ```

3. **shadcn Checkbox pattern:**
   ```tsx
   <div className="flex items-center gap-2 nodrag">
     <Checkbox
       id={`checkbox-${id}`}
       checked={nodeData.field}
       onCheckedChange={(checked) => {
         if (typeof checked === 'boolean') handleChange(checked);
       }}
     />
     <label htmlFor={`checkbox-${id}`} className="cursor-pointer">Label</label>
   </div>
   ```

### Pre-existing TypeScript Errors (Not Related to Changes)

The codebase has pre-existing TypeScript errors in template files and test files that are unrelated to this session's changes. These involve:
- Type mismatches in workflow template definitions
- Schema property type issues in ImageGenNode/VideoGenNode
- Test file type errors

### Next Steps

- [ ] Test all updated nodes in the Studio to verify functionality
- [ ] Verify dark/light theme compatibility
- [ ] Consider adding form validation feedback to Select components

---

## Session 37: Fix Group Feature Bugs (Viewport Transform & Drag)

**Duration:** ~15 minutes
**Status:** Complete

### System Flow Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                    GroupOverlay Component                    │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  useViewport() ──► { panX, panY, zoom }                    │
│        │                                                    │
│        ▼                                                    │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              Viewport Transform                       │  │
│  │  screenLeft = bounds.x * zoom + panX                 │  │
│  │  screenTop  = bounds.y * zoom + panY                 │  │
│  │  screenWidth = bounds.width * zoom                   │  │
│  │  screenHeight = bounds.height * zoom                 │  │
│  └──────────────────────────────────────────────────────┘  │
│        │                                                    │
│        ▼                                                    │
│  ┌─────────────────────┐  ┌──────────────────────────────┐ │
│  │ Group Background    │  │ Group Header                 │ │
│  │ pointer-events:none │  │ pointer-events:auto          │ │
│  │ (clicks pass thru)  │  │ (interactive + draggable)    │ │
│  └─────────────────────┘  └──────────────────────────────┘ │
│                                  │                          │
│                                  ▼                          │
│                           onMouseDown ──► capture start pos │
│                           onMouseMove ──► update node pos   │
│                           onMouseUp   ──► setDirty(true)    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### What Was Done

- [x] Fixed group stuck at top-left (0,0) - applied viewport transform
- [x] Fixed group not following pan/zoom - multiply by zoom, add pan offsets
- [x] Split group into two layers: background (pass-through) + header (interactive)
- [x] Increased z-index from z-0 to z-[5] to be above React Flow pane
- [x] Added group dragging - header drags all nodes in group together
- [x] Added e.stopPropagation() to button clicks to prevent drag interference
- [x] Scaled header height and font size with zoom level

### Root Cause

The `GroupOverlay` was using raw flow coordinates (`bounds.x`, `bounds.y`) without applying React Flow's viewport transform. Additionally, the entire component had `pointer-events-auto` on a `z-0` element, meaning it was behind React Flow's pane layer and all events were intercepted.

### Files Changed

| File | Change |
|------|--------|
| `apps/web/src/components/canvas/GroupOverlay.tsx` | Complete refactor: viewport transform, split layers, drag handling |

### Key Decisions

1. **Decision:** Split group into background + header layers
   - **Context:** Need background to not block node clicks, but header must be interactive
   - **Rationale:** `pointer-events-none` on background allows clicks to pass through to nodes

2. **Decision:** Use z-[5] instead of z-0
   - **Context:** React Flow pane at z-0 was capturing all events
   - **Rationale:** z-[5] is above pane but below most UI elements

3. **Decision:** Apply viewport transform manually
   - **Context:** GroupOverlay is a child of ReactFlow, but positioned absolutely
   - **Rationale:** Flow coordinates must be transformed: `(position * zoom) + pan`

### Mistakes & Fixes

1. **Mistake:** Initially called `setDirty()` without parameter
   - **Fix:** Changed to `setDirty(true)` since it requires a boolean

### Patterns Established

**Viewport Transform Pattern for React Flow Overlays:**
```tsx
const { x: panX, y: panY, zoom } = useViewport();

// Convert flow coords to screen coords
const screenX = flowX * zoom + panX;
const screenY = flowY * zoom + panY;
const screenWidth = flowWidth * zoom;
const screenHeight = flowHeight * zoom;
```

**Two-Layer Overlay Pattern:**
```tsx
<>
  {/* Background - visual only */}
  <div className="pointer-events-none" style={{ left, top, width, height }} />
  
  {/* Interactive header */}
  <div className="pointer-events-auto" onMouseDown={handleDrag}>
    {buttons}
  </div>
</>
```

### Next Steps

- [ ] Test group functionality: create, color change, lock/unlock, delete
- [ ] Test dragging group moves all nodes together
- [ ] Verify pan/zoom keeps group aligned with nodes


---

## Session 37: Auto-Layout Collision Detection & Edge Crossing Fix

**Duration:** ~20 minutes
**Status:** Complete

### What was done

- [x] Fixed auto-layout not using actual node dimensions (was using store nodes without `measured` property)
- [x] Implemented proper collision detection based on xyflow's recommended O(n²) approach
- [x] Added handle-aware node reordering to minimize edge crossings
- [x] Removed problematic `alignHandles` function that was causing node overlaps

### System Flow

```
┌─────────────────────────────────────────────────────────────────┐
│  Auto-Layout Pipeline                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. Get nodes from React Flow (with measured dimensions)         │
│         │                                                        │
│         ▼                                                        │
│  2. Dagre Layout (graph algorithm)                               │
│     - Uses actual node widths/heights                            │
│     - Respects edge relationships                                │
│         │                                                        │
│         ▼                                                        │
│  3. Reorder by Handle Position                                   │
│     - Groups nodes by target                                     │
│     - Sorts by target handle index                               │
│     - Swaps Y positions to minimize edge crossings               │
│         │                                                        │
│         ▼                                                        │
│  4. Collision Detection (O(n²) naive approach)                   │
│     - Checks all node pairs for bounding box overlap             │
│     - Pushes overlapping nodes apart symmetrically               │
│     - Iterates until no collisions (max 100 iterations)          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Files changed

- `apps/web/src/hooks/usePaneActions.ts` - Changed to use `reactFlow.getNodes()` and `reactFlow.getEdges()` instead of workflow store (which lacks `measured` dimensions)
- `apps/web/src/lib/autoLayout.ts` - Complete rewrite:
  - Removed `alignHandles` function (was causing overlaps)
  - Added `reorderByHandlePosition` to minimize edge crossings
  - Implemented `resolveCollisions` with proper bounding box detection
  - Increased spacing defaults (nodeSpacing: 80, rankSpacing: 150, MIN_GAP: 40)

### Decisions

- **Decision:** Use React Flow's internal nodes instead of workflow store nodes
  - **Context:** Workflow store nodes don't have `measured` property populated
  - **Rationale:** React Flow maintains actual rendered dimensions internally

- **Decision:** Remove handle alignment, add handle-aware reordering instead
  - **Context:** `alignHandles` was moving nodes to create horizontal edges but caused overlaps
  - **Rationale:** Better to keep nodes where dagre placed them, just reorder vertically to minimize crossings

- **Decision:** Implement O(n²) collision detection per xyflow blog recommendation
  - **Context:** https://xyflow.com/blog/node-collision-detection-algorithms
  - **Rationale:** Naive approach is fine for <100 nodes, symmetric pushing is more stable

### Technical Details

**Problem 1: Nodes overlapping after auto-layout**
- Root cause: `usePaneActions.autoLayout` used `nodes` from Zustand store which lacks `measured` dimensions
- Fix: Use `reactFlow.getNodes()` which has actual rendered dimensions

**Problem 2: Edge crossings**
- Root cause: Dagre doesn't know about handle positions on target nodes
- Fix: After dagre layout, reorder source nodes vertically based on which handle they connect to

**Collision detection algorithm:**
1. Get fresh bounding box for each node pair
2. Check AABB overlap with minimum gap
3. Calculate overlap on each axis
4. Push both nodes apart by half the overlap amount
5. Repeat until no collisions

### Patterns Established

**Collision detection pattern (from xyflow):**
```typescript
function resolveCollisions(nodes: Node[]): Node[] {
  while (hasCollision && iteration < maxIterations) {
    for (let i = 0; i < nodes.length; i++) {
      for (let j = i + 1; j < nodes.length; j++) {
        const rectA = getNodeRect(nodeA);
        const rectB = getNodeRect(nodeB);
        if (rectsOverlap(rectA, rectB, MIN_GAP)) {
          // Push apart symmetrically
          const overlap = getOverlap(rectA, rectB, MIN_GAP);
          nodeA.position.y -= overlap.y / 2;
          nodeB.position.y += overlap.y / 2;
        }
      }
    }
  }
}
```

### Next Steps

- [ ] Consider adding Flatbush R-tree for 500+ node workflows
- [ ] Custom edge routing to avoid crossing over nodes

---

## Session 38: Output Node Preview Minimum Dimensions

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Added `min-h-[120px]` to video preview container in OutputNode
- [x] Added `min-h-[120px]` to image preview container in OutputNode
- [x] Set default dimensions (280×320) for newly created output nodes
- [x] Added `min-w-[200px] min-h-[280px]` CSS constraints for output nodes in BaseNode
- [x] Updated NodeResizer constraints for output nodes (200×280 minimum)

### Problem

Output nodes with image/video previews became too short when the node was narrow. The `aspect-video` and `aspect-[4/3]` CSS classes calculate height from width, so a narrow node resulted in a tiny, unusable preview.

### Solution

Multi-layered approach to ensure output nodes always have usable preview sizes:

1. **Preview containers**: Added `min-h-[120px]` to both video and image preview divs
2. **Node container CSS**: Output nodes get `min-w-[200px] min-h-[280px]` (vs `min-w-[220px]` for other nodes)
3. **NodeResizer**: Output nodes cannot be resized below 200×280
4. **New node defaults**: Newly created output nodes start at 280×320

### Files Changed

| File | Changes |
|------|---------|
| `apps/web/src/components/nodes/output/OutputNode.tsx` | Added `min-h-[120px]` to video (line 97) and image (line 116) preview containers |
| `apps/web/src/components/nodes/BaseNode.tsx` | Added output-specific min dimensions in className and NodeResizer constraints |
| `apps/web/src/store/workflow/slices/nodeSlice.ts` | Added default width/height (280×320) for output nodes on creation |

### Decisions

- **Decision:** Use 200px minimum width and 280px minimum height for output nodes
  - **Context:** User showed screenshot where "Casual Output" node had good dimensions while "Outdoor...", "Beach...", "Office..." were too small
  - **Rationale:** The "Casual Output" example showed ~200px width is sufficient for readable previews

- **Decision:** Apply min dimensions at multiple layers
  - **Context:** Some output nodes may have been manually resized to small sizes
  - **Rationale:** CSS min dimensions apply regardless of stored width/height; NodeResizer prevents future undersizing

### Technical Details

**Before (OutputNode.tsx line 97):**
```tsx
<div className="relative aspect-video w-full overflow-hidden rounded-md bg-black/20">
```

**After:**
```tsx
<div className="relative aspect-video min-h-[120px] w-full overflow-hidden rounded-md bg-black/20">
```

**BaseNode.tsx className changes:**
```tsx
// Output nodes get larger minimums for better preview visibility
!isResized && type === 'output' && 'min-w-[200px] min-h-[280px]',
!isResized && type !== 'output' && 'min-w-[220px] max-w-[320px]',
```

**NodeResizer constraints:**
```tsx
minWidth={type === 'output' ? 200 : 220}
minHeight={type === 'output' ? 280 : 100}
```

### Next Steps

- [ ] Consider similar min-height treatment for other nodes with previews (ImageGen, VideoGen)
- [ ] Evaluate if 280px height is sufficient for video controls

---

## Session 39: Fix Replicate API 429 Rate Limiting

**Duration:** ~15 minutes
**Status:** Complete

### Problem

User triggered multiple image generations (clicking different imageGen nodes), causing Replicate API 429 "Too Many Requests" errors. Error showed rate limit of 6 requests/minute for accounts with <$5 credit.

### Root Cause Analysis

Two execution paths existed in the codebase:

| Function | Endpoint | BullMQ Queue? |
|----------|----------|---------------|
| `executeWorkflow()` | `/workflows/{id}/execute` | Yes (concurrency=1) |
| `executeSelectedNodes()` | `/workflows/{id}/execute` | Yes (concurrency=1) |
| `executeNode(nodeId)` | `/replicate/image` directly | **NO** |

The `executeNode()` function (used when clicking individual nodes) called the backend controller directly via `apiClient.post('/replicate/image')`, bypassing BullMQ entirely.

### System Flow (Before)

```
Path 1: executeWorkflow() / executeSelectedNodes()
  Frontend → /workflows/{id}/execute → BullMQ → Processor → Replicate
                                       (concurrency=1)
                                       ✅ Rate limited

Path 2: executeNode() [PROBLEMATIC]
  Frontend → /replicate/image → Controller → Service → Replicate
             (direct HTTP call)
             ❌ NO rate limiting
             ❌ Multiple parallel requests → 429 errors
```

### System Flow (After)

```
ALL execution paths now unified:

  executeNode(nodeId)
       │
       ▼
  setSelectedNodeIds([nodeId])
       │
       ▼
  executeSelectedNodes()
       │
       ▼
  /workflows/{id}/execute
       │
       ▼
  BullMQ Queue (concurrency=1)
       │
       ▼
  ImageProcessor → ReplicateService → Replicate API

  ✅ Rate limited (1 job at a time)
  ✅ Retry with exponential backoff (10s starting delay)
  ✅ Job tracking and status updates
```

### What was done

- [x] Identified root cause: `executeNode()` bypassed BullMQ queue
- [x] Refactored `executeNode()` to delegate to `executeSelectedNodes()`
- [x] Removed ~120 lines of duplicate code
- [x] Removed 2 unused imports (`pollPrediction`, `getOutputUpdate`)

### Files changed

- `apps/web/src/store/execution/slices/executionSlice.ts`
  - Replaced 126-line `executeNode()` with 7-line delegation to `executeSelectedNodes()`
  - Removed unused imports: `getOutputUpdate`, `pollPrediction`

### Code Change

**Before (126 lines):**
```typescript
executeNode: async (nodeId: string) => {
  // 126 lines of duplicate logic
  // Direct calls to /replicate/image, /replicate/video, etc.
  // NO rate limiting, NO queue
}
```

**After (7 lines):**
```typescript
executeNode: async (nodeId: string) => {
  const workflowStore = useWorkflowStore.getState();

  // Delegate to executeSelectedNodes - uses the BullMQ queue path
  // which provides rate limiting (concurrency=1) and retry with backoff
  workflowStore.setSelectedNodeIds([nodeId]);
  await get().executeSelectedNodes();
},
```

### Decisions

- **Decision:** Remove direct `/replicate/*` API calls from frontend, always use workflow execution queue
  - **Context:** Two code paths existed - one queued (workflow), one direct (single node)
  - **Rationale:** BullMQ already provides rate limiting (concurrency=1) and retry with exponential backoff. No reason to maintain a separate unqueued path.

### Benefits

1. **Rate limiting** - All Replicate API calls now go through BullMQ with concurrency=1
2. **Retry with backoff** - Failed requests automatically retry with 10s exponential backoff
3. **Code simplification** - Removed 120 lines of duplicate code
4. **Single code path** - One way to execute nodes, easier to maintain

### Next Steps

- [ ] Consider removing the direct `/replicate/*` endpoints from NestJS backend (now unused by frontend)
- [ ] Add credits/billing check before execution to prevent 429s proactively

---

## Session 40: Edge Selection Highlight Fix

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Fixed edge selection styling to highlight instead of dim
- [x] Selected edges now glow with their data type color instead of just changing to primary color
- [x] Added smooth transition animation for selection state

### Files changed

- `apps/web/src/app/globals.scss` - Reordered CSS rules and enhanced `.selected` edge styling

### Technical Details

**Problem:** When selecting an edge, it would lose its color and appear dimmed. The selected state (line 148-150) just changed stroke to `--primary`, but this was overridden by type-specific colors (edge-image, edge-video, etc.) that came after in the cascade.

**Solution:** 
1. Moved type-specific colors BEFORE the selected state
2. Changed selected styling to use `currentColor` (preserves type color)
3. Added visual emphasis: thicker stroke (3px), glow effect, brightness boost

**Before:**
```scss
&__edge.selected .react-flow__edge-path {
  stroke: var(--primary);  // Overridden by type colors below
}
&__edge.edge-image .react-flow__edge-path { stroke: var(--handle-image); }
// ... other type colors
```

**After:**
```scss
// Type colors first
&__edge.edge-image .react-flow__edge-path { stroke: var(--handle-image); }
// ... other type colors

// Selected state - preserves type color, adds highlight
&__edge.selected .react-flow__edge-path {
  stroke-width: 3px;
  filter: drop-shadow(0 0 6px currentColor) brightness(1.3);
  transition: stroke-width 0.15s ease, filter 0.15s ease;
}
```

### Decisions

- **Decision:** Use `currentColor` instead of `--primary` for selected edges
  - **Context:** Edges have data-type-specific colors (image=yellow, video=purple, text=teal, etc.)
  - **Rationale:** Preserving the type color while adding glow maintains visual consistency and data type identification

### Next Steps

- [ ] Consider similar highlight treatment for edge hover state

---

## Session 41: TTS → LipSync Propagation & Upstream-Only Selection

**Status:** Complete

### Problem
- LipSync button stayed disabled despite TTS having audio (inputAudio not populated)
- Selection highlighted downstream nodes instead of upstream dependencies

### Root Cause
- Output propagation only triggered for input node types - not generation nodes like TTS
- `getConnectedNodeIds()` traversed both directions instead of upstream only

### Files Changed
- **edgeSlice.ts**: `onConnect()` now propagates from ANY node with output
- **nodeSlice.ts**: `updateNodeData()` propagates when output fields set
- **persistenceSlice.ts**: Added propagation on load, upstream-only selection, audio handle support

### Result
- TTS.outputAudio → LipSync.inputAudio auto-populates on connect/update/load
- Selecting node highlights only upstream dependencies

---

## Session 18: Fix Audio Propagation & Add Image-Native Lip Sync Models

**Duration:** ~20 minutes
**Status:** Complete

### System Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                     Facecam Avatar Template Flow                             │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  ┌──────────┐     ┌─────────┐     ┌──────────────┐     ┌────────┐          │
│  │  Script  │────▶│   TTS   │────▶│   Lip Sync   │────▶│ Output │          │
│  │ (Prompt) │     │         │     │              │     │        │          │
│  └──────────┘     └─────────┘     └──────────────┘     └────────┘          │
│                        │ audio          ▲                                   │
│                        │                │ image                              │
│  ┌────────────────┐    │          ┌─────┴──────┐                            │
│  │  Face Image    │────┼─────────▶│  imageInput │                           │
│  │  (imageInput)  │    │          └────────────┘                            │
│  └────────────────┘    │                                                    │
│                        ▼                                                    │
│              ┌─────────────────────────────────────────────────┐           │
│              │              Model Selection                     │           │
│              ├─────────────────────────────────────────────────┤           │
│              │  IMAGE-NATIVE (no conversion needed):           │           │
│              │  • bytedance/omni-human  ←── Default for images │           │
│              │  • veed/fabric-1.0                              │           │
│              │  • pixverse/lipsync                             │           │
│              ├─────────────────────────────────────────────────┤           │
│              │  VIDEO-REQUIRED (auto image→video conversion):  │           │
│              │  • sync/lipsync-2                               │           │
│              │  • sync/lipsync-2-pro                           │           │
│              └─────────────────────────────────────────────────┘           │
└─────────────────────────────────────────────────────────────────────────────┘
```

### What was done

- [x] Fixed Zustand state timing issue causing audio not to propagate from TTS to LipSync
- [x] Added `imageInput`, `videoInput`, `audioInput` node types to propagation logic
- [x] Added `data.video` extraction in `getNodeOutput()` for videoInput nodes
- [x] Added new lip sync models: `bytedance/omni-human` and `veed/fabric-1.0`
- [x] Added `imageToVideo()` FFmpeg method for Sync Labs image→video conversion
- [x] Updated `handleLipSync` processor to auto-convert image→video for Sync Labs only
- [x] Updated facecam-avatar template to use `bytedance/omni-human` by default
- [x] Added `supportsImage` flag to model definitions in frontend

### Files changed

- `apps/web/src/store/workflow/slices/nodeSlice.ts`
  - Added optional `outputValue` param to `propagateOutputsDownstream()`
  - Pass output value directly to avoid stale Zustand state reads
  - Added `imageInput`, `videoInput`, `audioInput` to `getOutputType()`
  - Added `data.video` extraction for videoInput nodes
  - Added input node types to propagation trigger list

- `apps/web/src/components/nodes/ai/LipSyncNode.tsx`
  - Added `supportsImage` flag to model definitions
  - Added OmniHuman and VEED Fabric models
  - Updated help text based on model type (image vs video required)

- `apps/api/src/services/ffmpeg.service.ts`
  - Added `ImageToVideoInput` and `ImageToVideoResult` interfaces
  - Added `imageToVideo()` method to create static video from image

- `apps/api/src/services/replicate.service.ts`
  - Added `omniHuman` and `veedFabric` to MODELS constant
  - Added models to `LIP_SYNC_MODEL_MAP`
  - Added `IMAGE_NATIVE_LIP_SYNC_MODELS` list
  - Updated `generateLipSync()` to handle model-specific input formats

- `apps/api/src/processors/processing.processor.ts`
  - Auto-convert image→video for Sync Labs models only
  - Pass image directly to image-native models

- `packages/types/src/nodes.ts`
  - Added `bytedance/omni-human` and `veed/fabric-1.0` to LipSyncModel type

- `apps/web/src/templates/generated/facecam-avatar.ts`
  - Changed default model from `sync/lipsync-2` to `bytedance/omni-human`

### Decisions

- **Decision:** Add image-native lip sync models (OmniHuman, VEED Fabric)
  - **Context:** Sync Labs requires video input, but templates often have image input
  - **Rationale:** Better UX - use models designed for images rather than converting

- **Decision:** Keep image→video conversion for Sync Labs as fallback
  - **Context:** User might select Sync Labs but provide image
  - **Rationale:** Graceful degradation - still works but conversion needed

- **Decision:** Pass output value directly to propagateOutputsDownstream
  - **Context:** Zustand `get()` reads stale state immediately after `set()`
  - **Rationale:** Avoids race condition by not re-reading state

### Technical Details

**Root cause of audio propagation bug:**
When `updateNodeData(ttsId, { outputAudio })` called `set()`, then immediately called `propagateOutputsDownstream()` which used `get()` to read nodes. Zustand's batching meant the state wasn't committed yet, so `getNodeOutput(sourceNode)` read the OLD node data (null outputAudio).

**Lip sync model requirements:**
| Model | Input Required | Notes |
|-------|----------------|-------|
| bytedance/omni-human | image + audio | Best for images, ~$0.14/sec |
| veed/fabric-1.0 | image + audio | Social media talking heads |
| pixverse/lipsync | image + audio | Alternative |
| sync/lipsync-2 | **video** + audio | Requires video, auto-converts image |
| sync/lipsync-2-pro | **video** + audio | Higher quality |

### Mistakes/Fixes

- Initially only fixed propagation timing, but Sync Labs still required video
- Solution: Both fixes needed - propagation timing + proper model for image input

### Next Steps

- [ ] Test full facecam-avatar workflow with OmniHuman model
- [ ] Verify audio propagates correctly after TTS completes
- [ ] Consider adding model descriptions/cost info to dropdown
