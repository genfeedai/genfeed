# Sessions: 2026-01-29

**Summary:** TypeScript type fixes for MotionControlJobData

---

## Session 1: Fix MotionControlJobData Type Errors

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Fixed TypeScript errors in video.processor.ts for MotionControlJobData
- [x] Added `inputImage` and `inputPrompt` fields to MotionControlJobData interface
- [x] Removed unnecessary type casts in video processor

### Files changed

- `apps/api/src/interfaces/job-data.interface.ts` - Added `inputImage?: string` and `inputPrompt?: string` to MotionControlJobData interface to match VideoJobData pattern
- `apps/api/src/processors/video.processor.ts` - Removed `as string | undefined` casts since `image` field is required and fallback always returns string

### Decisions

- **Decision:** Add optional input fields to MotionControlJobData matching VideoJobData pattern
  - **Context:** Processor was using `inputPrompt` and `inputImage` fields that didn't exist on the type
  - **Rationale:** These fields come from node connections (vs legacy direct fields), consistent with other job data types

### Technical Details

The errors were:
1. `inputPrompt` property missing on MotionControlJobData
2. `inputImage` property missing on MotionControlJobData
3. `image` being `undefined` when passed to `generateMotionControlVideo`

Fix: Added the missing optional fields and removed unnecessary casts that were hiding the real types.

### Next steps

- [ ] Continue with other development tasks

---

## Session 2: Negative Prompt Checkbox Selector

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Created NegativePromptSelector component with checkbox-based UI
- [x] Integrated into SchemaInputs.tsx for `negative_prompt` schema fields
- [x] Added 8 predefined negative prompt options (Blurry, Distorted, Low Quality, etc.)
- [x] Added custom text input for additional terms

### Files created

- `apps/web/src/components/nodes/NegativePromptSelector.tsx` - New checkbox selector component for negative prompts

### Files changed

- `apps/web/src/components/nodes/SchemaInputs.tsx` - Added import and rendering logic for NegativePromptSelector when `key === 'negative_prompt'`

### Technical Details

**NegativePromptSelector features:**
- 8 predefined options in 2-column grid: Blurry, Distorted, Low Quality, Watermark, Text/Logos, Artifacts, Grainy/Noisy, Oversaturated
- Bidirectional parsing: parses existing comma-separated values to pre-check matching boxes
- Custom text input for additional terms not in predefined list
- Combines checked items + custom text into comma-separated output
- Memoized with `memo()` for performance

**Integration point in SchemaInputs.tsx:**
- Checks for `key === 'negative_prompt' && property.type === 'string'`
- Renders NegativePromptSelector instead of skipping string types
- Positioned before enum/slider/boolean logic in render loop

### Decisions

- **Decision:** Use 8 most common negative prompt terms
  - **Rationale:** These cover the majority of image/video quality issues users want to avoid
  - **Source:** Based on template defaults like `'blurry, distorted, low quality, watermark'`

### Next steps

- [ ] Test with SDXL or other models that have `negative_prompt` in schema
- [ ] Verify negative_prompt value is passed correctly to API

---

## Session 3: Fix EdgeStyle to Use React Flow's Actual Types

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Changed `EdgeStyle` type from `'bezier'` to `'default'` (React Flow's actual type for bezier curves)
- [x] Updated all default values and settings to use `'default'`
- [x] Added migration logic to convert legacy `'bezier'` values to `'default'`
- [x] Removed mapping functions that were converting between styles
- [x] Updated template seed data to use correct edge style

### System Flow

```
┌──────────────────────────────────────────────────────────────┐
│  EdgeStyle Migration Flow                                     │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  localStorage/Database                                        │
│         │                                                     │
│         ▼                                                     │
│  ┌─────────────────┐    ┌─────────────────┐                  │
│  │ edgeStyle:      │───▶│ Migration:      │                  │
│  │ 'bezier'        │    │ 'bezier'→       │                  │
│  │ (legacy)        │    │ 'default'       │                  │
│  └─────────────────┘    └────────┬────────┘                  │
│                                  │                            │
│                                  ▼                            │
│                         ┌─────────────────┐                  │
│                         │ React Flow:     │                  │
│                         │ type='default'  │                  │
│                         │ (bezier curves) │                  │
│                         └─────────────────┘                  │
│                                                               │
└──────────────────────────────────────────────────────────────┘
```

### Files changed

**Type Definition:**
- `packages/types/src/workflow.ts` - Changed EdgeStyle type: `'bezier'` → `'default'`

**Settings Store:**
- `apps/web/src/store/settingsStore.ts` - Updated type, default value, and added migration

**Settings UI:**
- `apps/web/src/components/settings/SettingsModal.tsx` - Updated EDGE_STYLES values

**Workflow Canvas:**
- `apps/web/src/components/canvas/WorkflowCanvas.tsx` - Removed `reactFlowEdgeType` mapping, uses `edgeStyle` directly

**Workflow Store:**
- `apps/web/src/store/workflow/workflowStore.ts` - Updated initial state
- `apps/web/src/store/workflow/slices/edgeSlice.ts` - Removed `toReactFlowEdgeType()`, uses style directly
- `apps/web/src/store/workflow/slices/persistenceSlice.ts` - Simplified to inline migration

**API/Backend:**
- `apps/api/src/schemas/user-settings.schema.ts` - Updated default value
- `apps/api/src/templates/templates.seed.ts` - Updated all templates

**UI Components:**
- `apps/web/src/components/templates/TemplatesModal.tsx` - Added migration for legacy values
- `apps/web/src/components/workflow/GenerateWorkflowModal.tsx` - Updated to use `'default'`

### Decisions

- **Decision:** Use `'default'` instead of `'bezier'` throughout the codebase
  - **Rationale:** React Flow uses `'default'` as the edge type name for bezier curves, not `'bezier'`. Using the correct type eliminates console warnings and makes the code match React Flow's expectations.

- **Decision:** Keep migration logic in place
  - **Rationale:** Existing users may have `'bezier'` stored in localStorage or database. Migration ensures backward compatibility.

### Technical Details

**Problem:** React Flow expects `'default'` for bezier curves but codebase used `'bezier'`, causing console warnings about unknown edge types.

**Solution:**
1. Changed the canonical type to `'default'`
2. Removed all conversion/mapping functions
3. Added migration in `loadFromStorage()`, `normalizeEdgeTypes()`, and `TemplatesModal` to handle legacy data

### Next steps

- [ ] Update test files to use `'default'` for consistency (currently using legacy `'bezier'`)
- [ ] Update documentation (SKILL.md, README files)

---

## Session 4: Pass debugMode Through Workflow Execution

**Duration:** ~20 minutes
**Status:** Complete

### What was done

- [x] Added `debugMode` to base job data interface (inherited by all job types)
- [x] Added `debugMode` field to Execution schema in MongoDB
- [x] Updated ExecutionsService to accept and store debugMode
- [x] Updated ExecutionsController to accept debugMode from request body
- [x] Updated QueueManagerService.enqueueWorkflow() to pass debugMode
- [x] Updated QueueManagerService.enqueueNode() to pass debugMode
- [x] Updated QueueManagerService.continueExecution() to read debugMode from execution record
- [x] Updated WorkflowProcessor to pass debugMode when enqueueing nodes
- [x] Updated ImageProcessor to pass debugMode to ReplicateService and handle mock response
- [x] Updated VideoProcessor with same debug mode handling
- [x] Updated frontend executionSlice to send debugMode in POST body
- [x] Updated SSE subscription to extract and display debug payloads from job results

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Debug Mode Workflow Execution Flow                                     │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  Frontend                                                               │
│  ┌─────────────────────────────────┐                                   │
│  │ Settings Store: debugMode=true  │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ POST /workflows/:id/execute     │                                   │
│  │ body: { debugMode: true }       │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│  Backend          │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ ExecutionsController            │                                   │
│  │ → createExecution(workflowId,   │                                   │
│  │    { debugMode })               │                                   │
│  │ → enqueueWorkflow(executionId,  │                                   │
│  │    workflowId, { debugMode })   │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ WorkflowJobData                 │                                   │
│  │ { debugMode: true, ... }        │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ WorkflowProcessor               │                                   │
│  │ → enqueueNode(..., { debugMode })│                                  │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ NodeJobData                     │                                   │
│  │ { debugMode: true, ... }        │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ ImageProcessor/VideoProcessor   │                                   │
│  │ → generateImage({ debugMode })  │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐     ┌──────────────────────────┐ │
│  │ ReplicateService                │────▶│ Returns mock response:   │ │
│  │ if (debugMode) return mock      │     │ { id, status, output,    │ │
│  │ else call Replicate API         │     │   debugPayload: {...} }  │ │
│  └─────────────────────────────────┘     └────────────┬─────────────┘ │
│                                                       │                │
│                   ┌───────────────────────────────────┘                │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ Job result saved with           │                                   │
│  │ debugPayload in MongoDB         │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ SSE Stream includes             │                                   │
│  │ job.result.debugPayload         │                                   │
│  └────────────────┬────────────────┘                                   │
│                   │                                                     │
│  Frontend         │                                                     │
│                   ▼                                                     │
│  ┌─────────────────────────────────┐                                   │
│  │ SSE Subscription extracts       │                                   │
│  │ debugPayloads, adds to store    │                                   │
│  │ → Opens Debug Panel             │                                   │
│  └─────────────────────────────────┘                                   │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Affected Components

**Backend:**
- `apps/api/src/interfaces/job-data.interface.ts`
- `apps/api/src/schemas/execution.schema.ts`
- `apps/api/src/services/executions.service.ts`
- `apps/api/src/services/queue-manager.service.ts`
- `apps/api/src/controllers/executions.controller.ts`
- `apps/api/src/processors/workflow.processor.ts`
- `apps/api/src/processors/image.processor.ts`
- `apps/api/src/processors/video.processor.ts`

**Frontend:**
- `apps/web/src/store/execution/slices/executionSlice.ts`
- `apps/web/src/store/execution/types.ts`
- `apps/web/src/store/execution/helpers/sseSubscription.ts`

### Key Decisions

- **Decision:** Store `debugMode` on the Execution record in MongoDB
  - **Rationale:** `continueExecution()` is called by processors after node completion. It needs to read debugMode to pass to subsequent nodes. Storing on execution record makes it accessible without passing through every function signature.

- **Decision:** Handle debug mode in processors, not in service
  - **Rationale:** Processors already handle the job lifecycle (status updates, logging, continuing execution). Handling debug mode there keeps the service focused on API interactions.

- **Decision:** Skip polling for debug predictions
  - **Rationale:** Mock predictions have no real Replicate ID to poll. Immediately completing with mock data is the correct behavior.

### Technical Details

**Problem:** Debug mode worked when clicking "Retry" on a node (direct API call to `/replicate/image`) but NOT when clicking "Run" in toolbar (workflow execution through queue).

**Root cause:**
- Retry path: Frontend → POST /replicate/image { debugMode } → Service
- Workflow path: Frontend → Controller → Queue → Processor → Service (debugMode never passed)

**Solution:** Thread debugMode through entire chain:
1. Frontend sends `{ debugMode }` in POST body
2. Controller stores in execution record AND passes to queue
3. Queue includes in WorkflowJobData
4. WorkflowProcessor passes to enqueueNode()
5. NodeJobData includes debugMode
6. Processors read from job.data and pass to service
7. Service returns mock response with debugPayload
8. Processor saves debugPayload to job result
9. SSE includes debugPayload in response
10. Frontend extracts and displays in Debug Panel

### Next steps

- [ ] Test end-to-end with Settings → Developer → Debug Mode enabled
- [ ] Verify debug panel shows captured payloads for all nodes
- [ ] Verify no actual Replicate API calls are made in debug mode

---

## Session 5: Debug Mode Bug Fixes and Schema Mapper Improvements

**Duration:** ~30 minutes
**Status:** Complete

### What was done

- [x] Fixed handle ID mapping: `images` → `inputImages` in execution slice
- [x] Fixed array normalization: Single images wrapped in arrays
- [x] Updated schema mapper to only send fields that exist in model's schema
- [x] Added enum validation to schema mapper (rejects invalid values like `webp` when only `jpg`/`png` allowed)
- [x] Improved base64 URL conversion with better logging and error handling
- [x] Fixed DebugPanel event propagation issues

### Files changed

**Frontend:**
- `apps/web/src/store/execution/slices/executionSlice.ts` - Added handleToFieldMap for mapping handle IDs to DTO fields, arrayFields normalization
- `apps/web/src/components/panels/DebugPanel.tsx` - Added `stopPropagation` to prevent click events from deselecting nodes

**Backend:**
- `apps/api/src/services/schema-mapper.service.ts` - Only send schema fields, added `isValidForSchema()` for enum validation
- `apps/api/src/services/files.service.ts` - Better URL parsing regex, more logging
- `apps/api/src/services/replicate.service.ts` - Added debug logging for image conversion

### Technical Details

**Handle ID Mapping:**
```typescript
const handleToFieldMap = {
  images: 'inputImages',  // Node handle ID → DTO field name
  image: 'image',
  video: 'video',
  prompt: 'prompt',
  audio: 'audio',
};
```

**Array Normalization:**
```typescript
const arrayFields = new Set(['inputImages', 'images']);
// Single values wrapped: 'url' → ['url']
```

**Schema Validation:**
- Before: Sent `resolution`, `output_format` even if model doesn't support them
- After: Only sends fields that exist in model's inputSchema
- Added enum check: If schema has `enum: ["jpg", "png"]`, rejects `webp`

### Mistakes and Fixes

1. **Missing images** - Fixed by mapping `images` handle → `inputImages` DTO field
2. **Single image as string** - Fixed by ensuring array fields always contain arrays
3. **422 Unprocessable Entity** - Fixed schema mapper to skip invalid enum values (e.g., `webp`)
4. **Extra fields** - Fixed schema mapper to only include fields that exist in model's schema

### Next steps

- [x] Debug mode feature complete and working

---

## Session 6: Fix Settings Modal Edge Style Preview

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Fixed edge style preview in Settings → Appearance tab
- [x] Nodes were positioned too far apart from the connecting edge
- [x] SVG path now properly connects Node A to Node B

### Files changed

- `apps/web/src/components/settings/SettingsModal.tsx` - Fixed preview layout:
  - Changed container from `max-w-[300px]` to fixed `w-[232px]` (64px + 104px + 64px)
  - Repositioned nodes: Node A at `left-0 bottom-2`, Node B at `right-0 top-2`
  - Updated SVG width from 136px to 104px to fill exact gap between nodes
  - Adjusted path coordinates to properly connect from Node A's right edge to Node B's left edge

### Technical Details

**Problem:** The preview showed Node A and Node B far apart from the curved edge line. The edge appeared to float in the middle without visually connecting to either node.

**Root cause:**
- Original: nodes at `left-8`/`right-8` (32px from edges) in a flexible-width container
- SVG was 100px wide, centered, but didn't reach the nodes

**Solution:**
- Fixed container width: 232px total (64px node + 104px edge + 64px node)
- Nodes positioned at edges: `left-0` and `right-0`
- SVG width matches exact gap: 104px starting at `left-16` (after Node A)
- Path coordinates: start at (0, 56) aligned with Node A center, end at (104, 24) aligned with Node B center

### Next steps

- [x] Continue with other development tasks

---

## Session 7: Fix React Flow Edge Handle Error

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Fixed React Flow error: "Couldn't create edge for target handle id: media"
- [x] Updated 12 template files to use correct handle IDs
- [x] Changed `targetHandle: 'media'` to `targetHandle: 'video'` for video connections
- [x] Changed `targetHandle: 'media'` to `targetHandle: 'image'` for image connections

### Root Cause

Templates were using `targetHandle: 'media'` when connecting to the Output node, but the Output node only has `image` and `video` input handles (defined in `packages/types/src/nodes.ts:1382-1385`), not a `media` handle.

### Files changed

**Video connections** (changed to `targetHandle: 'video'`):
- `apps/web/src/templates/image-to-video.ts`
- `apps/web/src/templates/full-pipeline.ts`
- `apps/web/src/templates/generated/facecam-avatar.ts`
- `apps/web/src/templates/generated/dance-video.ts`
- `apps/web/src/templates/generated/extended-video.ts`
- `apps/web/src/templates/generated/grid-to-video.ts`
- `apps/web/src/templates/generated/youtube-video-generator.ts`
- `apps/web/src/templates/generated/stream-to-social.ts`
- `apps/web/src/templates/generated/voice-to-video.ts`

**Image connections** (changed to `targetHandle: 'image'`):
- `apps/web/src/templates/image-series.ts`
- `apps/web/src/templates/generated/instagram-carousel.ts` (3 edges)
- `apps/web/src/templates/generated/social-brand-kit.ts` (4 edges)
- `apps/web/src/templates/generated/youtube-thumbnail-script.ts`

### Decisions

- **Decision:** Update templates to use correct handle IDs instead of adding a 'media' handle to Output node
  - **Rationale:** More explicit, matches actual node definition, avoids type detection complexity

### Known Issue

- `youtube-thumbnail-script.ts:241` has an edge connecting `sourceHandle: 'text'` to the output node, but Output node doesn't accept text inputs. This is a separate issue.

### Next steps

- [ ] Fix youtube-thumbnail-script.ts text-to-output edge (output node doesn't accept text)

---

## Session 8: Fix DebugPanel Double-Click and Clipboard Issues

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Diagnosed double-click issue in DebugPanel (clicks bubbling to React Flow canvas)
- [x] Diagnosed clipboard copy not working (event propagation interference)
- [x] Created reusable `PanelContainer` component for event isolation
- [x] Refactored DebugPanel to use PanelContainer (cleaner than individual stopPropagation calls)

### System Flow

```
┌────────────────────────────────────────────────────────────────┐
│  Event Propagation Problem & Solution                           │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  BEFORE (Problem):                                              │
│  ┌──────────────┐    ┌──────────────┐    ┌──────────────────┐ │
│  │ Button Click │───▶│ DebugPanel   │───▶│ React Flow       │ │
│  │ in Panel     │    │ (no stop)    │    │ Canvas handlers  │ │
│  └──────────────┘    └──────────────┘    └──────────────────┘ │
│                                            ↓                    │
│                                     Node deselection,           │
│                                     focus stealing,             │
│                                     requires 2nd click          │
│                                                                 │
│  AFTER (Solution):                                              │
│  ┌──────────────┐    ┌──────────────┐                          │
│  │ Button Click │───▶│ PanelContainer│    [Events stopped]     │
│  │ in Panel     │    │ stopPropagation│                        │
│  └──────────────┘    └──────────────┘                          │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
```

### Files created

- `apps/web/src/components/panels/PanelContainer.tsx` - Reusable wrapper that stops click/mouseDown/pointerDown/doubleClick propagation

### Files changed

- `apps/web/src/components/panels/DebugPanel.tsx` - Wrapped in PanelContainer, removed individual stopPropagation calls
- `apps/web/src/components/panels/index.ts` - Added PanelContainer export

### Technical Details

**Problem:**
1. Copy icon didn't work - clipboard API failed due to event interference
2. All buttons required double-click - first click was captured by React Flow's pane handlers

**Root cause:** Panels rendered as siblings to WorkflowCanvas still had events bubble up through the ReactFlowProvider context.

**Solution:** Created `PanelContainer` component that stops propagation at the container level:
```typescript
export const PanelContainer = forwardRef<HTMLDivElement, PanelContainerProps>(
  ({ children, className, ...props }, ref) => {
    const stopPropagation = (e: React.SyntheticEvent) => {
      e.stopPropagation();
    };
    return (
      <div
        onClick={stopPropagation}
        onMouseDown={stopPropagation}
        onPointerDown={stopPropagation}
        onDoubleClick={stopPropagation}
        {...props}
      >
        {children}
      </div>
    );
  }
);
```

**Why this is better than per-button stopPropagation:**
- Single point of event isolation
- No need to remember stopPropagation on every handler
- Reusable for other panels (AIGeneratorPanel, etc.)
- Cleaner component code

### Decisions

- **Decision:** Create reusable PanelContainer instead of adding stopPropagation to every button
  - **Rationale:** DRY principle - panels share the same event isolation need. One wrapper handles all.

- **Decision:** Stop multiple event types (click, mouseDown, pointerDown, doubleClick)
  - **Rationale:** React Flow uses different event types for different interactions. Comprehensive blocking prevents all interference.

### References

- [React Flow Utility Classes](https://reactflow.dev/learn/customization/utility-classes)
- [React Flow Panel Component](https://reactflow.dev/api-reference/components/panel)

### Next steps

- [ ] Apply PanelContainer to AIGeneratorPanel if it has similar issues
- [ ] Apply PanelContainer to NodePalette if needed

---

## Session 9: Collapse Negative Prompt Selector

**Duration:** ~5 minutes
**Status:** Complete

### What was done

- [x] Made NegativePromptSelector collapsible by default
- [x] Added expand/collapse toggle with chevron icon
- [x] Added "X selected" count indicator when collapsed

### Files changed

- `apps/web/src/components/nodes/NegativePromptSelector.tsx`
  - Added `isExpanded` state (default: `false`)
  - Added clickable header row with chevron icons (ChevronDown/ChevronRight from lucide-react)
  - Added `selectedCount` calculation showing number of checked items + custom text
  - Wrapped checkbox grid and custom input in conditional render based on `isExpanded`

### Technical Details

**Before:** Negative prompt options always visible, taking up significant node space

**After:**
- Collapsed by default - shows only "Negative Prompt" label with "X selected" count
- Click header to expand/collapse
- ChevronRight when collapsed, ChevronDown when expanded
- Selection count includes both predefined checkboxes and custom text (if non-empty)

### Decisions

- **Decision:** Collapse by default
  - **Rationale:** Negative prompt is a secondary option most users don't need to modify frequently. Collapsed state reduces visual clutter on nodes.

### Next steps

- [x] Feature complete

---

## Session 10: Fix Debug Payload Not Showing in SSE Stream

**Duration:** ~15 minutes
**Status:** Complete

### What was done

- [x] Fixed debug payloads not appearing in Debug Panel when running workflows from topbar
- [x] Added `result` field to Job schema for storing debug payload
- [x] Created `createDebugJob()` method in ExecutionsService
- [x] Updated ReplicateService to create Job records in debug mode

### System Flow

```
┌────────────────────────────────────────────────────────────────────────┐
│  Debug Payload Storage - Before vs After                                │
├────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  BEFORE (Bug):                                                          │
│  ┌──────────────────┐    ┌──────────────────┐                          │
│  │ ReplicateService │    │ QueueJob (queue_ │    Job (jobs)            │
│  │ generateImage()  │───▶│ jobs collection) │    collection:           │
│  │ debugMode=true   │    │ result: {        │    [NO RECORD            │
│  │                  │    │   debugPayload   │     CREATED]             │
│  │ Returns early,   │    │ }                │                          │
│  │ no createJob()   │    └──────────────────┘                          │
│  └──────────────────┘                                                   │
│                              ↓                                          │
│                       SSE queries Job collection                        │
│                       → No debugPayload found!                          │
│                                                                         │
│  AFTER (Fixed):                                                         │
│  ┌──────────────────┐    ┌──────────────────┐    ┌──────────────────┐ │
│  │ ReplicateService │    │ QueueJob (queue_ │    │ Job (jobs)       │ │
│  │ generateImage()  │───▶│ jobs collection) │    │ collection:      │ │
│  │ debugMode=true   │    │ ...              │    │ result: {        │ │
│  │                  │    └──────────────────┘    │   debugPayload   │ │
│  │ createDebugJob() │─────────────────────────▶│ }                │ │
│  └──────────────────┘                            └──────────────────┘ │
│                                                          ↓              │
│                                                   SSE queries Job       │
│                                                   → debugPayload found! │
│                                                                         │
└────────────────────────────────────────────────────────────────────────┘
```

### Root Cause

There are two separate job collections:
1. **`QueueJob`** (`queue_jobs` collection) - Used by BullMQ queue system
2. **`Job`** (`jobs` collection) - Used by SSE stream endpoint

In debug mode, `ReplicateService.generateImage/Video()` returned early with mock data but never created a `Job` record. The SSE stream queries the `jobs` collection via `findJobsByExecution()`, so it never found any debug payloads.

### Files changed

**Backend:**
- `apps/api/src/schemas/job.schema.ts` - Added `result?: Record<string, unknown>` field to store debug payload
- `apps/api/src/services/executions.service.ts` - Added `createDebugJob()` method that creates a Job record with mock predictionId, output, and debugPayload in result field
- `apps/api/src/services/replicate.service.ts` - Updated `generateImage()` and `generateVideo()` debug mode paths to call `createDebugJob()` before returning

### Technical Details

**New method in ExecutionsService:**
```typescript
async createDebugJob(
  executionId: string,
  nodeId: string,
  mockPredictionId: string,
  output: Record<string, unknown>,
  debugPayload: { model: string; input: Record<string, unknown>; timestamp: string }
): Promise<Job> {
  const job = new this.jobModel({
    executionId: new Types.ObjectId(executionId),
    nodeId,
    predictionId: mockPredictionId,
    status: 'succeeded',
    output,
    result: { debugPayload },
  });
  return job.save();
}
```

**Updated debug mode in ReplicateService:**
```typescript
if (input.debugMode) {
  const mockId = `debug-img-${Date.now()}`;
  // ... mock data setup ...

  // Create debug job record so SSE stream can return it
  await this.executionsService.createDebugJob(
    executionId,
    nodeId,
    mockId,
    { image: mockOutput },
    debugPayload
  );

  return { id: mockId, status: 'succeeded', output: mockOutput, debugPayload };
}
```

### Decisions

- **Decision:** Add `result` field to Job schema rather than modifying SSE to query QueueJob
  - **Rationale:** Keeps SSE stream simple, Job schema is the right place for API response data

- **Decision:** Create Job record with mock predictionId in debug mode
  - **Rationale:** Job schema requires unique predictionId. Using `debug-img-{timestamp}` ensures uniqueness while being clearly identifiable as debug data

### Next steps

- [x] Debug mode feature complete

---

## Session 11: Fix Debug Panel Copy Button and Clean Legacy URL Code

**Duration:** ~10 minutes
**Status:** Complete

### What was done

- [x] Fixed DebugPanel copy button not working (added `stopPropagation` + `execCommand` fallback)
- [x] Removed legacy URL format handling from codebase (no `@deprecated` backward compat)
- [x] Cleaned up `urlToBase64` to only handle current URL format

### Files changed

**Frontend:**
- `apps/web/src/components/panels/DebugPanel.tsx`
  - Added `e.stopPropagation()` to `handleCopy` to prevent event bubbling
  - Added `execCommand('copy')` fallback when clipboard API fails

**Backend:**
- `apps/api/src/services/files.service.ts`
  - Simplified `urlToBase64` to only handle `/api/files/workflows/{id}/input/{filename}` format
  - Removed legacy `/api/files/input/{id}/{filename}` pattern handling

### Technical Details

**Copy button fix:**
```typescript
const handleCopy = useCallback(
  async (e: React.MouseEvent) => {
    e.stopPropagation();
    try {
      await navigator.clipboard.writeText(JSON.stringify(payload.input, null, 2));
      // ... success handling
    } catch {
      // Fallback to execCommand for older browsers/restricted contexts
      const textArea = document.createElement('textarea');
      textArea.value = JSON.stringify(payload.input, null, 2);
      // ... fallback implementation
    }
  },
  [payload.input]
);
```

**Root cause of old URLs:** User had workflow documents in MongoDB with old URL format from before route migration. Solution: re-upload images to get new URLs.

### Decisions

- **Decision:** Remove legacy URL handling instead of maintaining backward compatibility
  - **Rationale:** User prefers clean code over deprecated cruft. Old URLs in database can be fixed by re-uploading files.

### Next steps

- [ ] Re-upload images in workflows that have old URL format
