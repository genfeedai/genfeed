import type { WorkflowEdge, WorkflowNode } from '@genfeedai/types';
import { NODE_DEFINITIONS } from '@genfeedai/types';

/**
 * Binary fields by node type - fields containing base64 data URLs or large media
 */
const BINARY_FIELDS_BY_TYPE: Record<string, string[]> = {
  imageInput: ['image'],
  imageGen: ['inputImages', 'outputImage', 'outputImages'],
  videoGen: ['inputImage', 'lastFrame', 'referenceImages', 'outputVideo'],
  llm: ['inputImages'],
  annotation: ['inputImage', 'outputImage'],
  resize: ['inputMedia', 'outputMedia'],
  reframe: ['inputImage', 'inputVideo', 'outputImage', 'outputVideo'],
  upscale: [
    'inputImage',
    'inputVideo',
    'outputImage',
    'outputVideo',
    'originalPreview',
    'outputPreview',
  ],
  imageGridSplit: ['inputImage', 'outputImages'],
  videoStitch: ['inputVideos', 'outputVideo'],
  videoTrim: ['inputVideo', 'outputVideo'],
  videoFrameExtract: ['inputVideo', 'outputImage'],
  animation: ['inputVideo', 'outputVideo'],
  lipSync: ['inputImage', 'inputVideo', 'inputAudio', 'outputVideo'],
  voiceChange: ['inputVideo', 'inputAudio', 'outputVideo'],
  textToSpeech: ['outputAudio'],
  motionControl: ['inputImage', 'inputVideo', 'outputVideo'],
  subtitle: ['inputVideo', 'outputVideo'],
  output: ['inputImage', 'inputVideo'],
  outputGallery: ['images'],
  imageCompare: ['imageA', 'imageB'],
  prompt: [],
  promptConstructor: [],
  template: [],
};

/**
 * Fields to strip completely (irrelevant for editing context)
 */
const STRIP_FIELDS = ['cachedOutput', 'lockTimestamp', 'jobId', 'progress'];

/**
 * Stripped node with binary data replaced by metadata placeholders
 */
export interface StrippedNode {
  id: string;
  type: string;
  position: { x: number; y: number };
  data: Record<string, unknown>;
}

/**
 * Lightweight workflow context for LLM consumption.
 */
export interface WorkflowContext {
  nodeCount: number;
  nodes: StrippedNode[];
  connections: Array<{
    from: string;
    to: string;
    sourceHandle: string | null;
    targetHandle: string | null;
  }>;
  isEmpty: boolean;
}

/**
 * Formats a binary field placeholder with metadata.
 */
function formatBinaryPlaceholder(value: string | string[], fieldName: string): string {
  if (Array.isArray(value)) {
    if (value.length === 0) return '[no media]';
    return `[${value.length} item(s)]`;
  }

  const isUrl = value.startsWith('http://') || value.startsWith('https://');
  const isVideo = fieldName.toLowerCase().includes('video');
  const type = isVideo ? 'video' : 'image';

  if (isUrl) {
    return `[${type}: URL]`;
  }

  // Base64 size estimation
  const sizeKB = Math.round((value.length * 3) / 4 / 1024);
  return `[${type}: ${sizeKB}KB]`;
}

/**
 * Strips binary data from workflow nodes, preserving all parameters
 * and adding metadata placeholders.
 */
export function stripBinaryData(nodes: WorkflowNode[]): StrippedNode[] {
  return nodes.map((node) => {
    const strippedData: Record<string, unknown> = {};
    const binaryFields = BINARY_FIELDS_BY_TYPE[node.type ?? ''] || [];

    for (const [key, value] of Object.entries(node.data)) {
      if (STRIP_FIELDS.includes(key)) continue;

      if (binaryFields.includes(key)) {
        if (value === null || value === undefined) {
          strippedData[key] = value;
        } else {
          strippedData[key] = formatBinaryPlaceholder(value as string | string[], key);
        }
      } else {
        strippedData[key] = value;
      }
    }

    return {
      id: node.id,
      type: node.type ?? 'unknown',
      position: node.position,
      data: strippedData,
    };
  });
}

/**
 * Builds a lightweight workflow context from nodes and edges.
 */
export function buildWorkflowContext(
  nodes: WorkflowNode[],
  edges: WorkflowEdge[]
): WorkflowContext {
  const isEmpty = nodes.length === 0;
  const strippedNodes = stripBinaryData(nodes);

  const connections = edges.map((edge) => ({
    from: edge.source,
    to: edge.target,
    sourceHandle: edge.sourceHandle || null,
    targetHandle: edge.targetHandle || null,
  }));

  return {
    nodeCount: nodes.length,
    nodes: strippedNodes,
    connections,
    isEmpty,
  };
}

/**
 * Formats workflow context as a readable string for injection into LLM system prompt.
 */
export function formatContextForPrompt(context: WorkflowContext): string {
  if (context.isEmpty) {
    return 'The canvas is currently empty.';
  }

  const lines: string[] = [];

  lines.push(`Current workflow has ${context.nodeCount} node(s):`);
  for (const node of context.nodes) {
    const def = NODE_DEFINITIONS[node.type as keyof typeof NODE_DEFINITIONS];
    const title = (node.data.label as string) || def?.label || node.type;
    lines.push(`  - ${node.id}: ${title} (${node.type})`);
  }

  if (context.connections.length > 0) {
    lines.push('');
    lines.push('Connections:');
    for (const conn of context.connections) {
      const handleInfo = conn.sourceHandle ? ` (${conn.sourceHandle})` : '';
      lines.push(`  - ${conn.from} â†’ ${conn.to}${handleInfo}`);
    }
  }

  return lines.join('\n');
}
